<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Playground</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Sorting bar styles */
        .sort-bar {
            width: 100%;
            transition: height 0.3s ease, background-color 0.1s ease; /* Faster color transition */
            margin: 0 1px;
            border-radius: 4px 4px 0 0;
            position: relative; /* Added for label positioning */
        }
        
        .sort-bar-label {
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            font-weight: 600;
            color: white;
            background-color: rgba(0,0,0,0.4); /* Slightly darker background */
            padding: 0 3px;
            border-radius: 3px;
            white-space: nowrap;
            /* Prevent label selection */
            -webkit-user-select: none; /* Safari */
            -ms-user-select: none; /* IE 10+ */
            user-select: none; /* Standard */
        }

        /* Pathfinding grid cell styles */
        .grid-cell {
            width: 100%;
            padding-bottom: 100%; /* Creates a perfect square aspect ratio */
            position: relative;
            border: 1px solid #374151; /* gray-700 */
            transition: background-color 0.1s ease, transform 0.2s ease;
            cursor: pointer; /* Indicate interactivity */
        }
        
        .grid-cell.start { background-color: #10B981; cursor: grab; } /* emerald-500 */
        .grid-cell.end { background-color: #EF4444; cursor: grab; } /* red-500 */
        .grid-cell.wall { 
            background-color: #111827; /* gray-900 */
            transform: scale(0.9);
            border-radius: 20%; /* Rounded walls */
        }
        .grid-cell.visited { 
            background-color: #3B82F6; /* blue-500 */
            animation: pulse-visited 0.5s ease;
        }
        .grid-cell.path { 
            background-color: #F59E0B; /* amber-500 */
            animation: pulse-path 0.8s ease;
            border-radius: 30%; /* Rounded path */
        }
        
        @keyframes pulse-visited {
            0% { transform: scale(0.7); border-radius: 50%; background-color: #60A5FA; } /* blue-400 */
            50% { transform: scale(1.1); }
            100% { transform: scale(1); border-radius: 0; background-color: #3B82F6; } /* blue-500 */
        }
        @keyframes pulse-path {
            0% { transform: scale(0.6); background-color: #FBBF24; } /* amber-400 */
            100% { transform: scale(1); background-color: #F59E0B; } /* amber-500 */
        }

        /* Custom slider track */
        input[type="range"]::-webkit-slider-runnable-track {
            background: #374151; /* gray-700 */
            height: 8px;
            border-radius: 4px;
        }
        input[type="range"]::-moz-range-track {
            background: #374151; /* gray-700 */
            height: 8px;
            border-radius: 4px;
        }
        /* Custom slider thumb */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3B82F6; /* blue-500 */
            cursor: pointer;
            margin-top: -6px; /* Center thumb on track */
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3B82F6; /* blue-500 */
            cursor: pointer;
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1F2937; /* gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4B5563; /* gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6B7280; /* gray-500 */
        }

    </style>
</head>
<body class="bg-gray-900 text-gray-200 min-h-screen flex flex-col">

    <!-- Header -->
    <header class="bg-gray-800 shadow-lg rounded-b-lg sticky top-0 z-10">
        <div class="container mx-auto px-4 py-4 flex flex-wrap justify-between items-center gap-4">
            <h1 class="text-2xl md:text-3xl font-bold text-white">Algorithm Playground</h1>
            <!-- Tabs -->
            <div class="flex flex-wrap bg-gray-700 rounded-lg p-1">
                <button id="tab-sorting" class="tab-btn bg-blue-600 text-white px-3 py-2 rounded-md text-sm font-medium">Sorting</button>
                <button id="tab-searching" class="tab-btn text-gray-300 px-3 py-2 rounded-md text-sm font-medium">Searching</button>
                <button id="tab-pathfinding" class="tab-btn text-gray-300 px-3 py-2 rounded-md text-sm font-medium">Pathfinding</button>
                <button id="tab-dp" class="tab-btn text-gray-300 px-3 py-2 rounded-md text-sm font-medium">Dynamic Programming</button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto p-4 flex-grow flex flex-col lg:flex-row gap-4">

        <!-- Left Panel: Controls & Complexity -->
        <div class="w-full lg:w-1/3 xl:w-1/4 flex flex-col gap-4">
            
            <!-- Controls Panel -->
            <div class="bg-gray-800 p-4 rounded-lg shadow-xl">
                <h2 class="text-xl font-bold mb-4 border-b border-gray-700 pb-2">Controls</h2>
                
                <!-- Sorting Controls (Visible by default) -->
                <div id="controls-sorting">
                    <div class="mb-4">
                        <label for="algo-select-sorting" class="block text-sm font-medium text-gray-400 mb-1">Algorithm</label>
                        <select id="algo-select-sorting" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="bubbleSort">Bubble Sort</option>
                            <option value="mergeSort">Merge Sort</option>
                            <option value="quickSort">Quick Sort</option>
                            <option value="insertionSort">Insertion Sort</option>
                            <option value="selectionSort">Selection Sort</option>
                            <option value="heapSort">Heap Sort</option>
                        </select>
                    </div>
                    <div class="mb-4">
                        <label for="speed-slider-sorting" class="block text-sm font-medium text-gray-400 mb-1">Speed</label>
                        <input id="speed-slider-sorting" type="range" min="10" max="500" value="100" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                    </div>
                     <div class="mb-4">
                        <label for="size-slider-sorting" class="block text-sm font-medium text-gray-400 mb-1">Random Array Size: <span id="size-label-sorting">50</span></label>
                        <input id="size-slider-sorting" type="range" min="10" max="100" value="50" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="mb-4">
                        <label for="custom-array-sorting" class="block text-sm font-medium text-gray-400 mb-1">Custom Array (e.g., 50,10,88)</label>
                        <textarea id="custom-array-sorting" rows="2" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Enter comma-separated numbers"></textarea>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-2 mb-2">
                        <button id="btn-generate-array" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Use Random Array</button>
                        <button id="btn-use-custom-array-sorting" class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Use Custom Array</button>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-2">
                        <button id="btn-start-sorting" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Start Sort</button>
                        <button id="btn-stop-sorting" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 opacity-50 cursor-not-allowed" disabled>Stop</button>
                    </div>
                </div>

                <!-- Searching Controls (Hidden by default) -->
                <div id="controls-searching" class="hidden">
                    <div class="mb-4">
                        <label for="algo-select-searching" class="block text-sm font-medium text-gray-400 mb-1">Algorithm</label>
                        <select id="algo-select-searching" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="linearSearch">Linear Search</option>
                            <option value="binarySearch">Binary Search</option>
                        </select>
                    </div>
                    <div class="mb-4">
                        <label for="target-input-searching" class="block text-sm font-medium text-gray-400 mb-1">Target Value</label>
                        <input id="target-input-searching" type="number" min="0" value="42" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-2">
                    </div>
                     <div class="mb-4"> <!-- Added Size Slider for Searching -->
                        <label for="size-slider-searching" class="block text-sm font-medium text-gray-400 mb-1">Random Array Size: <span id="size-label-searching">30</span></label>
                        <input id="size-slider-searching" type="range" min="10" max="100" value="30" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="mb-4">
                        <label for="custom-array-searching" class="block text-sm font-medium text-gray-400 mb-1">Custom Array (e.g., 50,10,88)</label>
                        <textarea id="custom-array-searching" rows="2" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Enter comma-separated numbers"></textarea>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-2 mb-2">
                        <button id="btn-generate-array-searching" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Use Random Array</button>
                        <button id="btn-use-custom-array-searching" class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Use Custom Array</button>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-2">
                        <button id="btn-start-searching" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Start Search</button>
                        <button id="btn-stop-searching" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 opacity-50 cursor-not-allowed" disabled>Stop</button>
                    </div>
                    <p class="text-xs text-gray-500 mt-2">Note: Binary Search requires a sorted array. Random/Custom arrays will be sorted automatically.</p>
                </div>

                <!-- Pathfinding Controls (Hidden by default) -->
                <div id="controls-pathfinding" class="hidden">
                    <div class="mb-4">
                        <label for="algo-select-pathfinding" class="block text-sm font-medium text-gray-400 mb-1">Algorithm</label>
                        <select id="algo-select-pathfinding" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="dijkstra">Dijkstra's Algorithm</option>
                            <option value="aStar">A* Search</option>
                            <option value="bfs">Breadth-First Search (BFS)</option>
                            <option value="dfs">Depth-First Search (DFS)</option>
                        </select>
                    </div>
                    <p class="text-sm text-gray-400 mb-4">
                        Click/Drag to add walls. <br>
                        Drag Start (Green) & End (Red) nodes.
                    </p>
                    <div class="flex flex-col sm:flex-row gap-2 mb-2">
                        <button id="btn-reset-grid" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Reset Grid</button>
                        <button id="btn-clear-path" class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Clear Path</button>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-2">
                        <button id="btn-start-pathfinding" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Start Search</button>
                        <button id="btn-stop-pathfinding" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 opacity-50 cursor-not-allowed" disabled>Stop</button>
                    </div>
                </div>

                <!-- DP Controls (Hidden by default) -->
                <div id="controls-dp" class="hidden">
                    <div class="mb-4">
                        <label for="algo-select-dp" class="block text-sm font-medium text-gray-400 mb-1">Algorithm</label>
                        <select id="algo-select-dp" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="fibonacci">Fibonacci (Memoized)</option>
                            <option value="knapsack">0/1 Knapsack</option>
                            <option value="lcs">Longest Common Subsequence</option>
                        </select>
                    </div>
                    <!-- Dynamic controls for DP -->
                    <div id="dp-inputs-container">
                        <!-- JS will populate this -->
                    </div>
                    <div class="flex flex-col sm:flex-row gap-2 mt-4">
                        <button id="btn-start-dp" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Start</button>
                        <button id="btn-stop-dp" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 opacity-50 cursor-not-allowed" disabled>Stop</button>
                    </div>
                </div>
            </div>

            <!-- Complexity Panel -->
            <div class="bg-gray-800 p-4 rounded-lg shadow-xl flex-grow">
                <h2 class="text-xl font-bold mb-4 border-b border-gray-700 pb-2">Complexity Analysis</h2>
                <div id="complexity-info">
                    <!-- Content is dynamically inserted by JS -->
                </div>
            </div>
        </div>

        <!-- Right Panel: Visualizer -->
        <div class="w-full lg:w-2/3 xl:w-3/4 bg-gray-800 p-4 rounded-lg shadow-xl flex items-center justify-center min-h-[400px] lg:min-h-[60vh]">
            
            <!-- Sorting Visualizer (Visible by default) -->
            <div id="visualizer-sorting" class="w-full h-full flex items-end justify-center gap-[1px]">
                <!-- Bars are dynamically inserted by JS -->
            </div>

            <!-- Searching Visualizer (Hidden by default) -->
            <div id="visualizer-searching" class="hidden w-full h-full flex items-end justify-center gap-[1px]">
                <!-- Bars are dynamically inserted by JS -->
            </div>

            <!-- Pathfinding Visualizer (Hidden by default) -->
            <div id="visualizer-pathfinding" class="hidden w-full h-full aspect-square max-w-[80vh]">
                <div id="grid-container" class="grid w-full h-full">
                    <!-- Grid cells are dynamically inserted by JS -->
                </div>
            </div>

            <!-- DP Visualizer (Hidden by default) -->
            <div id="visualizer-dp" class="hidden w-full h-full flex-col items-center justify-center p-4">
                 <!-- DP Table/Result will go here -->
                <div id="dp-output-container" class="w-full h-full mt-4 overflow-auto text-center">
                    <!-- Content updated by JS -->
                     <p class="text-gray-400 text-lg">Dynamic Programming Visualizer</p>
                     <p class="text-gray-500">Select an algorithm and press Start.</p>
                </div>
            </div>
        </div>
    </main>
    
    <!-- JavaScript -->
    <script type="module">
        // --- STATE MANAGEMENT ---
        let currentView = 'sorting'; // 'sorting', 'searching', 'pathfinding', 'dp'
        let currentSortingAlgorithm = 'bubbleSort';
        let currentSearchingAlgorithm = 'linearSearch';
        let currentPathfindingAlgorithm = 'dijkstra';
        let currentDPAlgorithm = 'fibonacci';
        
        let sortSpeed = 410; // Default speed adjusted (510 - 100)
        let sortArraySize = 50; // Renamed for clarity
        let searchArraySize = 30; // Separate size for searching
        let sortingArray = [];
        let searchingArray = []; // For the searching tab
        
        // Global stop flag
        let forceStop = false;
        
        // State flags
        let isSorting = false;
        let isSearching = false;
        let isPathfinding = false;
        let isDPRunning = false;
        let currentAlgorithmExecution = null; // To store the current async process


        const GRID_ROWS = 25;
        const GRID_COLS = 25;
        let grid = [];
        let startNode = { row: 5, col: 5 };
        let endNode = { row: 19, col: 19 };
        let isDrawingWalls = false;
        let isMovingStart = false;
        let isMovingEnd = false;

        // --- COMPLEXITY DATA ---
        // ... (Complexity data remains the same) ...
         const complexityData = {
            bubbleSort: {
                title: 'Bubble Sort',
                time: { best: 'O(n)', average: 'O(n²)', worst: 'O(n²)', },
                space: 'O(1)',
                explanation: `<p class="mb-2"><strong class="text-gray-300">Time:</strong> It has an average and worst-case time of <code class="code">O(n²)</code> because it uses nested loops to compare and swap elements.</p><p class="mb-2"><strong class="text-gray-300">Best Case:</strong> <code class="code">O(n)</code> if already sorted (with optimization).</p><p><strong class="text-gray-300">Space:</strong> <code class="code">O(1)</code> - In-place.</p>`
            },
            insertionSort: {
                title: 'Insertion Sort',
                time: { best: 'O(n)', average: 'O(n²)', worst: 'O(n²)', },
                space: 'O(1)',
                explanation: `<p class="mb-2"><strong class="text-gray-300">Time:</strong> Worst/average case <code class="code">O(n²)</code> due to shifting elements.</p><p class="mb-2"><strong class="text-gray-300">Best Case:</strong> <code class="code">O(n)</code> if already sorted.</p><p><strong class="text-gray-300">Space:</strong> <code class="code">O(1)</code> - In-place.</p>`
            },
            selectionSort: {
                title: 'Selection Sort',
                time: { best: 'O(n²)', average: 'O(n²)', worst: 'O(n²)', },
                space: 'O(1)',
                explanation: `<p class="mb-2"><strong class="text-gray-300">Time:</strong> Always <code class="code">O(n²)</code> as it finds the minimum in each pass.</p><p><strong class="text-gray-300">Space:</strong> <code class="code">O(1)</code> - In-place.</p>`
            },
            heapSort: {
                title: 'Heap Sort',
                time: { best: 'O(n log n)', average: 'O(n log n)', worst: 'O(n log n)', },
                space: 'O(1)',
                explanation: `<p class="mb-2"><strong class="text-gray-300">Time:</strong> Consistently <code class="code">O(n log n)</code> due to heapify operations.</p><p><strong class="text-gray-300">Space:</strong> <code class="code">O(1)</code> - In-place (heap built within the array).</p>`
            },
            mergeSort: {
                title: 'Merge Sort',
                time: { best: 'O(n log n)', average: 'O(n log n)', worst: 'O(n log n)', },
                space: 'O(n)',
                explanation: `<p class="mb-2"><strong class="text-gray-300">Time:</strong> Consistently <code class="code">O(n log n)</code> due to divide and conquer.</p><p><strong class="text-gray-300">Space:</strong> <code class="code">O(n)</code> - Requires temporary arrays for merging.</p>`
            },
            quickSort: {
                title: 'Quick Sort',
                time: { best: 'O(n log n)', average: 'O(n log n)', worst: 'O(n²)', },
                space: 'O(log n)',
                explanation: `<p class="mb-2"><strong class="text-gray-300">Time (Average):</strong> <code class="code">O(n log n)</code> via partitioning.</p><p class="mb-2"><strong class="text-gray-300">Worst Case:</strong> <code class="code">O(n²)</code> with bad pivots (e.g., sorted data).</p><p><strong class="text-gray-300">Space:</strong> <code class="code">O(log n)</code> average (recursion stack), <code class="code">O(n)</code> worst case.</p>`
            },
            linearSearch: {
                title: 'Linear Search',
                time: { best: 'O(1)', average: 'O(n)', worst: 'O(n)', },
                space: 'O(1)',
                explanation: `<p class="mb-2"><strong class="text-gray-300">Time:</strong> Scans sequentially. Best <code class="code">O(1)</code> (first element), worst/avg <code class="code">O(n)</code>.</p><p><strong class="text-gray-300">Space:</strong> <code class="code">O(1)</code>.</p>`
            },
            binarySearch: {
                title: 'Binary Search',
                time: { best: 'O(1)', average: 'O(log n)', worst: 'O(log n)', },
                space: 'O(1)',
                explanation: `<p class="mb-2"><strong class="text-gray-300">Time:</strong> Works on <strong class="text-gray-300">sorted arrays</strong>. Divides search space by half each time, resulting in <code class="code">O(log n)</code>.</p><p><strong class="text-gray-300">Space:</strong> <code class="code">O(1)</code> (iterative).</p>`
            },
            dijkstra: {
                title: "Dijkstra's Algorithm",
                time: { best: 'O(E + V log V)', average: 'O(E + V log V)', worst: 'O(E + V log V)', },
                space: 'O(V)',
                explanation: `<p class="mb-2"><strong class="text-gray-300">Notation:</strong> V=vertices, E=edges.</p><p class="mb-2"><strong class="text-gray-300">Time:</strong> <code class="code">O(E + V log V)</code> with a min-priority queue (binary heap). For a grid, simplifies to <code class="code">O(V log V)</code>.</p><p><strong class="text-gray-300">Space:</strong> <code class="code">O(V)</code> to store distances/previous nodes.</p>`
            },
            aStar: {
                title: "A* Search",
                time: { best: 'O(E+V)', average: 'O(E+V)', worst: 'O(E log V)', }, // Adjusted worst case for grid with good heuristic
                space: 'O(V)',
                explanation: `<p class="mb-2"><strong class="text-gray-300">Time:</strong> Depends on heuristic 'h'. Can be <code class="code">O(E+V)</code> in best case. Often performs like Dijkstra (<code class="code">O(E log V)</code> or <code class="code">O(V log V)</code> on grid) in worst practical cases.</p><p class="mb-2"><strong class="text-gray-300">Logic:</strong> Uses heuristic <code class="code">f(n)=g(n)+h(n)</code> to prioritize promising nodes.</p><p><strong class="text-gray-300">Space:</strong> <code class="code">O(V)</code> for the open/closed sets.</p>`
            },
            bfs: {
                title: "Breadth-First Search (BFS)",
                time: { best: 'O(V + E)', average: 'O(V + E)', worst: 'O(V + E)', },
                space: 'O(V)',
                explanation: `<p class="mb-2"><strong class="text-gray-300">Time:</strong> Explores layer by layer. Visits each vertex/edge once: <code class="code">O(V + E)</code>.</p><p class="mb-2"><strong class="text-gray-300">Logic:</strong> Uses a Queue (FIFO). Finds shortest path in unweighted graphs.</p><p><strong class="text-gray-300">Space:</strong> <code class="code">O(V)</code> - Queue can hold up to all nodes at one level.</p>`
            },
            dfs: {
                title: "Depth-First Search (DFS)",
                time: { best: 'O(V + E)', average: 'O(V + E)', worst: 'O(V + E)', },
                space: 'O(V)',
                explanation: `<p class="mb-2"><strong class="text-gray-300">Time:</strong> Explores deeply before backtracking. Visits each vertex/edge once: <code class="code">O(V + E)</code>.</p><p class="mb-2"><strong class="text-gray-300">Logic:</strong> Uses a Stack (LIFO). Doesn't guarantee shortest path.</p><p><strong class="text-gray-300">Space:</strong> <code class="code">O(V)</code> - Stack depth can be up to V in worst case.</p>`
            },
            fibonacci: {
                title: "Fibonacci (Memoized DP)",
                time: { best: 'O(n)', average: 'O(n)', worst: 'O(n)', },
                space: 'O(n)',
                explanation: `<p class="mb-2"><strong class="text-gray-300">Time:</strong> Naive recursion is <code class="code">O(2ⁿ)</code>. Memoization computes each <code class="code">fib(k)</code> once: <code class="code">O(n)</code>.</p><p><strong class="text-gray-300">Space:</strong> <code class="code">O(n)</code> for storing computed values (memoization table or recursion stack).</p>`
            },
            knapsack: {
                title: "0/1 Knapsack (DP)",
                time: { best: 'O(N * W)', average: 'O(N * W)', worst: 'O(N * W)', },
                space: 'O(N * W) or O(W)', // Added optimized space
                explanation: `<p class="mb-2"><strong class="text-gray-300">Notation:</strong> N=items, W=capacity.</p><p class="mb-2"><strong class="text-gray-300">Time:</strong> Fills an <code class="code">N x W</code> DP table: <code class="code">O(N * W)</code>.</p><p><strong class="text-gray-300">Space:</strong> <code class="code">O(N * W)</code> for the full table, can be optimized to <code class="code">O(W)</code>.</p>`
            },
            lcs: {
                title: "Longest Common Subsequence (DP)",
                time: { best: 'O(M * N)', average: 'O(M * N)', worst: 'O(M * N)', },
                space: 'O(M * N) or O(min(M,N))', // Added optimized space
                explanation: `<p class="mb-2"><strong class="text-gray-300">Notation:</strong> M, N = lengths of strings.</p><p class="mb-2"><strong class="text-gray-300">Time:</strong> Fills an <code class="code">M x N</code> DP table: <code class="code">O(M * N)</code>.</p><p><strong class="text-gray-300">Space:</strong> <code class="code">O(M * N)</code> for the full table (needed for reconstruction), length calculation can be optimized to <code class="code">O(min(M,N))</code>.</p>`
            }
        };


        // --- DOM ELEMENTS ---
        const tabSorting = document.getElementById('tab-sorting');
        const tabSearching = document.getElementById('tab-searching');
        const tabPathfinding = document.getElementById('tab-pathfinding');
        const tabDp = document.getElementById('tab-dp');
        
        const controlsSorting = document.getElementById('controls-sorting');
        const controlsSearching = document.getElementById('controls-searching');
        const controlsPathfinding = document.getElementById('controls-pathfinding');
        const controlsDp = document.getElementById('controls-dp');
        
        const visualizerSorting = document.getElementById('visualizer-sorting');
        const visualizerSearching = document.getElementById('visualizer-searching');
        const visualizerPathfinding = document.getElementById('visualizer-pathfinding');
        const visualizerDp = document.getElementById('visualizer-dp');
        const gridContainer = document.getElementById('grid-container');

        // Sorting controls
        const algoSelectSorting = document.getElementById('algo-select-sorting');
        const speedSliderSorting = document.getElementById('speed-slider-sorting');
        const sizeSliderSorting = document.getElementById('size-slider-sorting');
        const sizeLabelSorting = document.getElementById('size-label-sorting'); // Label for size value
        const customArraySorting = document.getElementById('custom-array-sorting');
        const btnGenerateArray = document.getElementById('btn-generate-array');
        const btnUseCustomArraySorting = document.getElementById('btn-use-custom-array-sorting');
        const btnStartSorting = document.getElementById('btn-start-sorting');
        const btnStopSorting = document.getElementById('btn-stop-sorting');

        // Searching controls
        const algoSelectSearching = document.getElementById('algo-select-searching');
        const targetInputSearching = document.getElementById('target-input-searching');
        const sizeSliderSearching = document.getElementById('size-slider-searching'); // Added
        const sizeLabelSearching = document.getElementById('size-label-searching'); // Added
        const customArraySearching = document.getElementById('custom-array-searching');
        const btnGenerateArraySearching = document.getElementById('btn-generate-array-searching');
        const btnUseCustomArraySearching = document.getElementById('btn-use-custom-array-searching');
        const btnStartSearching = document.getElementById('btn-start-searching');
        const btnStopSearching = document.getElementById('btn-stop-searching');

        // Pathfinding controls
        const algoSelectPathfinding = document.getElementById('algo-select-pathfinding');
        const btnResetGrid = document.getElementById('btn-reset-grid');
        const btnClearPath = document.getElementById('btn-clear-path');
        const btnStartPathfinding = document.getElementById('btn-start-pathfinding');
        const btnStopPathfinding = document.getElementById('btn-stop-pathfinding');

        // DP controls
        const algoSelectDp = document.getElementById('algo-select-dp');
        const dpInputsContainer = document.getElementById('dp-inputs-container');
        const dpOutputContainer = document.getElementById('dp-output-container');
        const btnStartDp = document.getElementById('btn-start-dp');
        const btnStopDp = document.getElementById('btn-stop-dp');

        const complexityInfo = document.getElementById('complexity-info');

        // --- UTILITY FUNCTIONS ---
        // Debounce function to limit rapid calls (e.g., from sliders)
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                clearTimeout(timeout);
                func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        const sleep = (ms) => new Promise(resolve => {
            // Allow stopping during sleep
            const timeoutId = setTimeout(resolve, ms);
            // Check forceStop periodically within sleep
            const checkStop = setInterval(() => {
                if (forceStop) {
                    clearTimeout(timeoutId);
                    clearInterval(checkStop);
                    resolve(); // Resolve immediately if stopped
                }
            }, 10); // Check every 10ms
            // Clear interval when sleep completes normally
            // Use requestAnimationFrame to ensure interval cleared after timeout resolves
            requestAnimationFrame(() => clearTimeout(timeoutId));
            requestAnimationFrame(() => clearInterval(checkStop));
        });
        
        
        const stopAlgorithm = () => {
            console.log("Stop requested");
            forceStop = true; 
            // The running async function should detect forceStop and exit.
            // Re-enabling controls is now handled within the main algorithm functions when they exit due to forceStop.
        };

        const disableControls = (view) => {
            forceStop = false; // Reset stop flag on start
            console.log(`Disabling controls for: ${view}`);
            
            if (view === 'sorting') {
                isSorting = true;
                btnStartSorting.disabled = true;
                btnGenerateArray.disabled = true;
                btnUseCustomArraySorting.disabled = true;
                algoSelectSorting.disabled = true;
                sizeSliderSorting.disabled = true;
                customArraySorting.disabled = true;
                btnStartSorting.classList.add('opacity-50', 'cursor-not-allowed');
                btnGenerateArray.classList.add('opacity-50', 'cursor-not-allowed');
                btnUseCustomArraySorting.classList.add('opacity-50', 'cursor-not-allowed');
                sizeSliderSorting.classList.add('cursor-not-allowed'); // Disable slider visually
                
                btnStopSorting.disabled = false;
                btnStopSorting.classList.remove('opacity-50', 'cursor-not-allowed');

            } else if (view === 'searching') {
                isSearching = true;
                btnStartSearching.disabled = true;
                btnGenerateArraySearching.disabled = true;
                btnUseCustomArraySearching.disabled = true;
                algoSelectSearching.disabled = true;
                targetInputSearching.disabled = true;
                sizeSliderSearching.disabled = true; // Disable new slider
                customArraySearching.disabled = true;
                btnStartSearching.classList.add('opacity-50', 'cursor-not-allowed');
                btnGenerateArraySearching.classList.add('opacity-50', 'cursor-not-allowed');
                btnUseCustomArraySearching.classList.add('opacity-50', 'cursor-not-allowed');
                sizeSliderSearching.classList.add('cursor-not-allowed'); // Disable slider visually

                btnStopSearching.disabled = false;
                btnStopSearching.classList.remove('opacity-50', 'cursor-not-allowed');

            } else if (view === 'pathfinding') {
                isPathfinding = true;
                btnStartPathfinding.disabled = true;
                btnResetGrid.disabled = true;
                btnClearPath.disabled = true;
                algoSelectPathfinding.disabled = true;
                btnStartPathfinding.classList.add('opacity-50', 'cursor-not-allowed');
                btnResetGrid.classList.add('opacity-50', 'cursor-not-allowed');
                btnClearPath.classList.add('opacity-50', 'cursor-not-allowed');
                gridContainer.style.cursor = 'not-allowed'; // Indicate grid is inactive

                btnStopPathfinding.disabled = false;
                btnStopPathfinding.classList.remove('opacity-50', 'cursor-not-allowed');
                
            } else if (view === 'dp') {
                isDPRunning = true;
                btnStartDp.disabled = true;
                algoSelectDp.disabled = true;
                btnStartDp.classList.add('opacity-50', 'cursor-not-allowed');
                dpInputsContainer.querySelectorAll('input, textarea').forEach(el => { el.disabled = true; el.classList.add('opacity-50'); });
                
                btnStopDp.disabled = false;
                btnStopDp.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        };

        const enableControls = (view) => {
            console.log(`Enabling controls for: ${view}`);
             if (view === 'sorting') {
                isSorting = false;
                btnStartSorting.disabled = false;
                btnGenerateArray.disabled = false;
                btnUseCustomArraySorting.disabled = false;
                algoSelectSorting.disabled = false;
                sizeSliderSorting.disabled = false;
                customArraySorting.disabled = false;
                btnStartSorting.classList.remove('opacity-50', 'cursor-not-allowed');
                btnGenerateArray.classList.remove('opacity-50', 'cursor-not-allowed');
                btnUseCustomArraySorting.classList.remove('opacity-50', 'cursor-not-allowed');
                sizeSliderSorting.classList.remove('cursor-not-allowed');

                btnStopSorting.disabled = true;
                btnStopSorting.classList.add('opacity-50', 'cursor-not-allowed');

            } else if (view === 'searching') {
                isSearching = false;
                btnStartSearching.disabled = false;
                btnGenerateArraySearching.disabled = false;
                btnUseCustomArraySearching.disabled = false;
                algoSelectSearching.disabled = false;
                targetInputSearching.disabled = false;
                sizeSliderSearching.disabled = false; // Enable new slider
                customArraySearching.disabled = false;
                btnStartSearching.classList.remove('opacity-50', 'cursor-not-allowed');
                btnGenerateArraySearching.classList.remove('opacity-50', 'cursor-not-allowed');
                btnUseCustomArraySearching.classList.remove('opacity-50', 'cursor-not-allowed');
                sizeSliderSearching.classList.remove('cursor-not-allowed');

                btnStopSearching.disabled = true;
                btnStopSearching.classList.add('opacity-50', 'cursor-not-allowed');
                
            } else if (view === 'pathfinding') {
                isPathfinding = false;
                btnStartPathfinding.disabled = false;
                btnResetGrid.disabled = false;
                btnClearPath.disabled = false;
                algoSelectPathfinding.disabled = false;
                btnStartPathfinding.classList.remove('opacity-50', 'cursor-not-allowed');
                btnResetGrid.classList.remove('opacity-50', 'cursor-not-allowed');
                btnClearPath.classList.remove('opacity-50', 'cursor-not-allowed');
                gridContainer.style.cursor = 'default';
                
                btnStopPathfinding.disabled = true;
                btnStopPathfinding.classList.add('opacity-50', 'cursor-not-allowed');
                
            } else if (view === 'dp') {
                isDPRunning = false;
                btnStartDp.disabled = false;
                algoSelectDp.disabled = false;
                btnStartDp.classList.remove('opacity-50', 'cursor-not-allowed');
                dpInputsContainer.querySelectorAll('input, textarea').forEach(el => { el.disabled = false; el.classList.remove('opacity-50'); });

                btnStopDp.disabled = true;
                btnStopDp.classList.add('opacity-50', 'cursor-not-allowed');
            }
            forceStop = false; // Ensure flag is reset after controls enabled
        };

        // --- VIEW SWITCHING ---
        const switchView = (view) => {
            // Stop any running algorithm before switching
            if (isSorting || isSearching || isPathfinding || isDPRunning) {
                stopAlgorithm(); // Set the flag
                // Small delay to allow current async step to potentially finish or check flag
                setTimeout(() => { 
                    performViewSwitch(view); 
                }, 50); 
            } else {
                 performViewSwitch(view);
            }
        };

        const performViewSwitch = (view) => {
            currentView = view;
            console.log("Switching view to:", view);
            
            // Reset all tabs
            [tabSorting, tabSearching, tabPathfinding, tabDp].forEach(tab => {
                tab.classList.remove('bg-blue-600', 'text-white');
                tab.classList.add('text-gray-300', 'hover:bg-gray-600'); // Add hover effect back
            });
            // Hide all controls
            [controlsSorting, controlsSearching, controlsPathfinding, controlsDp].forEach(c => c.classList.add('hidden'));
            // Hide all visualizers
            [visualizerSorting, visualizerSearching, visualizerPathfinding, visualizerDp].forEach(v => v.classList.add('hidden'));
            visualizerSorting.classList.remove('flex'); 
            visualizerSearching.classList.remove('flex'); 
            visualizerDp.classList.remove('flex'); 

            // Enable the correct view
            if (view === 'sorting') {
                tabSorting.classList.add('bg-blue-600', 'text-white');
                tabSorting.classList.remove('hover:bg-gray-600');
                controlsSorting.classList.remove('hidden');
                visualizerSorting.classList.remove('hidden');
                visualizerSorting.classList.add('flex');
                if (sortingArray.length === 0) generateArray(false); 
                else drawArray(sortingArray, visualizerSorting, customArraySorting.value.trim() !== ''); // Show labels if custom array exists

            } else if (view === 'searching') {
                tabSearching.classList.add('bg-blue-600', 'text-white');
                tabSearching.classList.remove('hover:bg-gray-600');
                controlsSearching.classList.remove('hidden');
                visualizerSearching.classList.remove('hidden');
                visualizerSearching.classList.add('flex');
                if (searchingArray.length === 0) generateArray(true); 
                else drawArray(searchingArray, visualizerSearching, true); 

            } else if (view === 'pathfinding') {
                tabPathfinding.classList.add('bg-blue-600', 'text-white');
                tabPathfinding.classList.remove('hover:bg-gray-600');
                controlsPathfinding.classList.remove('hidden');
                visualizerPathfinding.classList.remove('hidden');
                if (grid.length === 0) createGrid();

            } else if (view === 'dp') {
                tabDp.classList.add('bg-blue-600', 'text-white');
                tabDp.classList.remove('hover:bg-gray-600');
                controlsDp.classList.remove('hidden');
                visualizerDp.classList.remove('hidden');
                visualizerDp.classList.add('flex'); 
                updateDPInputs();
            }
            
            // Ensure controls are enabled for the new view
            enableControls(view);
            updateComplexityInfo();
        };


        // --- DP INPUTS LOGIC ---
        // ... (updateDPInputs remains the same) ...
        const updateDPInputs = () => {
            currentDPAlgorithm = algoSelectDp.value;
            dpInputsContainer.innerHTML = ''; // Clear old inputs
            dpOutputContainer.innerHTML = `<p class="text-gray-400 text-lg">Dynamic Programming Visualizer</p> <p class="text-gray-500">Select inputs and press Start.</p>`; // Clear old output with placeholder
            
            const baseInputClass = "w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-2 mt-1 focus:outline-none focus:ring-2 focus:ring-blue-500";
            const baseLabelClass = "block text-sm font-medium text-gray-400";
            const baseSmallTextClass = "text-xs text-gray-500 mt-1";


            if (currentDPAlgorithm === 'fibonacci') {
                dpInputsContainer.innerHTML = `
                    <div class="mb-4">
                        <label for="dp-fib-n" class="${baseLabelClass}">Fibonacci (n):</label>
                        <input id="dp-fib-n" type="number" min="0" max="90" value="10" class="${baseInputClass}"> 
                         <p class="${baseSmallTextClass}">Max 90 due to JS number limits.</p>
                    </div>
                `;
            } else if (currentDPAlgorithm === 'knapsack') {
                dpInputsContainer.innerHTML = `
                    <div class="mb-4">
                        <label for="dp-knapsack-weights" class="${baseLabelClass}">Weights (comma-sep):</label>
                        <input id="dp-knapsack-weights" type="text" value="10,20,30" class="${baseInputClass}"> <!-- Updated example -->
                         <p class="${baseSmallTextClass}">Example: 10, 20, 30</p>
                    </div>
                    <div class="mb-4">
                        <label for="dp-knapsack-values" class="${baseLabelClass}">Values (comma-sep):</label>
                        <input id="dp-knapsack-values" type="text" value="60,100,120" class="${baseInputClass}">
                        <p class="${baseSmallTextClass}">Must match number of weights.</p>
                    </div>
                    <div class="mb-4">
                        <label for="dp-knapsack-capacity" class="${baseLabelClass}">Capacity:</label>
                        <input id="dp-knapsack-capacity" type="number" min="1" value="50" class="${baseInputClass}">
                    </div>
                `;
            } else if (currentDPAlgorithm === 'lcs') {
                dpInputsContainer.innerHTML = `
                    <div class="mb-4">
                        <label for="dp-lcs-s1" class="${baseLabelClass}">String 1:</label>
                        <input id="dp-lcs-s1" type="text" value="AGGTAB" maxlength="50" class="${baseInputClass}">
                    </div>
                    <div class="mb-4">
                        <label for="dp-lcs-s2" class="${baseLabelClass}">String 2:</label>
                        <input id="dp-lcs-s2" type="text" value="GXTXAYB" maxlength="50" class="${baseInputClass}">
                         <p class="${baseSmallTextClass}">Max length 50 for visualization.</p>
                    </div>
                `;
            }
            updateComplexityInfo();
        };


        // --- COMPLEXITY PANEL LOGIC ---
        // ... (updateComplexityInfo remains mostly the same, just formatting) ...
          const updateComplexityInfo = () => {
            let algoKey;
            switch (currentView) {
                case 'sorting': algoKey = currentSortingAlgorithm; break;
                case 'searching': algoKey = currentSearchingAlgorithm; break;
                case 'pathfinding': algoKey = currentPathfindingAlgorithm; break;
                case 'dp': algoKey = currentDPAlgorithm; break;
                default: algoKey = 'bubbleSort';
            }
            
            const data = complexityData[algoKey];

            if (!data) {
                complexityInfo.innerHTML = '<p>Select an algorithm to see its analysis.</p>';
                return;
            }
            
            // Shared style for code blocks
            const codeStyle = "font-mono bg-gray-700 px-1.5 py-0.5 rounded text-xs text-blue-300 mx-1"; // Adjusted style

            // Ensure explanation uses the codeStyle consistently
            const formattedExplanation = data.explanation.replace(/<code class="code">/g, `<code class="${codeStyle}">`);


            complexityInfo.innerHTML = `
                <h3 class="text-xl font-semibold text-white mb-3">${data.title}</h3>
                <div class="space-y-4 text-gray-400 text-sm">
                    <div>
                        <h4 class="font-semibold text-gray-300 mb-1">Time Complexity</h4>
                        <ul class="list-none pl-2 space-y-1">
                            <li><span class="w-16 inline-block">Best:</span> <code class="${codeStyle}">${data.time.best}</code></li>
                            <li><span class="w-16 inline-block">Average:</span> <code class="${codeStyle}">${data.time.average}</code></li>
                            <li><span class="w-16 inline-block">Worst:</span> <code class="${codeStyle}">${data.time.worst}</code></li>
                        </ul>
                    </div>
                    <div>
                        <h4 class="font-semibold text-gray-300 mb-1">Space Complexity</h4>
                        <p class="pl-2">Total: <code class="${codeStyle}">${data.space}</code></p>
                    </div>
                    <div>
                        <h4 class="font-semibold text-gray-300 mb-1">Explanation</h4>
                        <div class="pl-2 space-y-2 text-gray-400">${formattedExplanation}</div>
                    </div>
                </div>
            `;
        };


        // --- SORTING/SEARCHING ARRAY LOGIC ---
        
        // 1. Draw Array
        const drawArray = (array, visualizer, showLabels = false) => {
            visualizer.innerHTML = '';
            if (!array || array.length === 0) return; // Prevent errors on empty array

            const maxVal = Math.max(1, ...array); // Avoid division by zero if max is 0
            const minVal = Math.min(0, ...array); // Handle potential negative numbers if needed, though current logic generates positive
            const range = maxVal - minVal;
             // Ensure effectiveMax is at least 1, prevent division by zero or negative heights
            const effectiveMax = Math.max(1, range); 

            // Determine if labels should be shown based on size and explicit flag
            const displayLabels = showLabels || array.length <= 40; 

            for (let i = 0; i < array.length; i++) {
                const value = array[i];
                // Scale height: ensure minimum height (e.g., 5%), scale based on range
                 const percentHeight = Math.max(5, ((value - minVal) / effectiveMax) * 90 + 5); 
                
                const bar = document.createElement('div');
                bar.style.height = `${percentHeight}%`;
                 // Add base color class, specific color classes will replace this
                bar.classList.add('sort-bar', 'bg-blue-500');
                // Adjust bar width dynamically
                const barWidthPercentage = Math.max(0.5, Math.min(90 / array.length, 10)); // Min width 0.5%, Max 10%
                bar.style.width = `${barWidthPercentage}%`;
                
                if (displayLabels) {
                    const label = document.createElement('span');
                    label.innerText = value;
                    label.classList.add('sort-bar-label');
                    if (array.length > 30 || barWidthPercentage < 3) label.style.fontSize = '8px'; // Smaller if crowded or narrow bars
                     if (barWidthPercentage < 1.5) label.style.display = 'none'; // Hide if bars too narrow
                    bar.appendChild(label);
                }
                
                visualizer.appendChild(bar);
            }
        };


        // 2. Generate Random Array
        const generateArray = (isSearchTab) => {
            if (isSorting || isSearching) return;
            
            // Use the correct size variable based on the tab
            const size = isSearchTab ? searchArraySize : sortArraySize; 
            
            let newArray = [];
            for (let i = 0; i < size; i++) {
                // Generate values between 1 and 100 for simplicity
                const value = Math.floor(Math.random() * 100) + 1; 
                newArray.push(value);
            }
            
            if (isSearchTab) {
                // Clear custom array input when generating random
                customArraySearching.value = ''; 
                if (currentSearchingAlgorithm === 'binarySearch') {
                    newArray.sort((a,b) => a-b);
                }
                searchingArray = [...newArray];
                drawArray(searchingArray, visualizerSearching, true); // Always show labels for searching
            } else {
                 // Clear custom array input when generating random
                customArraySorting.value = '';
                sortingArray = [...newArray];
                 // Show labels if few bars, regardless of custom input
                drawArray(sortingArray, visualizerSorting, sortArraySize <= 40); 
            }
        };


        // 3. Parse Custom Array
        const parseCustomArray = (input) => {
            // Allow spaces, filter non-numeric results after split
            return input
                .split(/[\s,]+/) // Split by comma OR space
                .map(item => item.trim()) // Trim whitespace
                .filter(item => item !== '') // Remove empty strings resulting from multiple spaces/commas
                .map(item => parseInt(item, 10)) // Convert to number
                .filter(num => !isNaN(num)); // Filter out any NaN values (invalid numbers)
        };
        
        // 4. Use Custom Array
        const useCustomArray = (isSearchTab) => {
            if (isSorting || isSearching) return;
            
            const textarea = isSearchTab ? customArraySearching : customArraySorting;
            const input = textarea.value;
            let newArray = parseCustomArray(input);
            
            if (newArray.length === 0) {
                console.error("Invalid custom array. Please enter comma-separated/space-separated numbers.");
                textarea.value = "ERROR: Invalid Input";
                 // Clear the array state and visualizer
                if (isSearchTab) {
                    searchingArray = [];
                    drawArray([], visualizerSearching);
                } else {
                    sortingArray = [];
                    drawArray([], visualizerSorting);
                }
                return;
            }
            
            // Cap array size for performance/visualization reasons
            if (newArray.length > 100) { 
                newArray = newArray.slice(0, 100); 
                textarea.value = newArray.join(','); // Update textarea to show capped array
                console.warn("Custom array size capped at 100 elements.");
            }
            
            if (isSearchTab) {
                // Update the search array size state to match custom input
                searchArraySize = newArray.length; 
                sizeSliderSearching.value = searchArraySize; // Update slider position
                sizeLabelSearching.textContent = searchArraySize; // Update slider label

                if (currentSearchingAlgorithm === 'binarySearch') {
                    newArray.sort((a,b) => a-b);
                    textarea.value = newArray.join(', '); // Show sorted version in textarea
                }
                searchingArray = [...newArray];
                drawArray(searchingArray, visualizerSearching, true); // Always show labels
            } else {
                 // Update the sort array size state to match custom input
                sortArraySize = newArray.length;
                sizeSliderSorting.value = sortArraySize; // Update slider position
                sizeLabelSorting.textContent = sortArraySize; // Update slider label

                sortingArray = [...newArray];
                drawArray(sortingArray, visualizerSorting, true); // Always show labels for custom arrays
            }
        };


        // 5. Start Sorting
        // ... (startSorting remains mostly the same, ensure it uses sortingArray) ...
         const startSorting = async () => {
            if (sortingArray.length === 0) {
                useCustomArray(false); // Try custom first
                 if (sortingArray.length === 0) generateArray(false); // Fallback to random
            }
            if (sortingArray.length === 0) return; // Don't start if array is still empty
            
            disableControls('sorting');
            currentAlgorithmExecution = bubbleSort; // Placeholder, will be set below
            
            const bars = visualizerSorting.getElementsByClassName('sort-bar');

            try {
                switch (currentSortingAlgorithm) {
                    case 'bubbleSort': currentAlgorithmExecution = bubbleSort; await bubbleSort(bars); break;
                    case 'insertionSort': currentAlgorithmExecution = insertionSort; await insertionSort(bars); break;
                    case 'selectionSort': currentAlgorithmExecution = selectionSort; await selectionSort(bars); break;
                    case 'heapSort': currentAlgorithmExecution = heapSort; await heapSort(bars); break;
                    case 'mergeSort': currentAlgorithmExecution = mergeSort; await mergeSort(bars, 0, sortingArray.length - 1); break;
                    case 'quickSort': currentAlgorithmExecution = quickSort; await quickSort(bars, 0, sortingArray.length - 1); break;
                }
            } catch (error) {
                 if (error.message === 'Algorithm stopped') {
                    console.log('Sorting stopped by user.');
                } else {
                    console.error('Error during sorting:', error);
                }
            } finally {
                 // Finish animation ONLY if not stopped
                 if (!forceStop) {
                    for (let i = 0; i < bars.length; i++) {
                        if(bars[i]) {
                             // Use replace to ensure only green remains
                             bars[i].classList.remove('bg-red-500', 'bg-yellow-500', 'bg-purple-500', 'bg-gray-600');
                             bars[i].classList.replace('bg-blue-500', 'bg-green-500'); // Ensure base blue is also replaced
                             bars[i].classList.add('bg-green-500'); // Add green just in case replace didn't find blue
                        }
                       await sleep(5); // Small delay even for final coloring
                       if(forceStop) break; // Allow stopping during final sweep
                    }
                } else {
                    // If stopped, reset colors immediately by redrawing
                    drawArray(sortingArray, visualizerSorting, customArraySorting.value.trim() !== '');
                }
                enableControls('sorting');
                currentAlgorithmExecution = null;
            }
        };


        // --- Helper function to reset all bar colors to blue ---
        const resetBarColors = (bars) => {
             for(let i = 0; i < bars.length; i++) {
                 if(bars[i]) {
                    bars[i].classList.remove('bg-red-500', 'bg-yellow-500', 'bg-purple-500', 'bg-gray-600', 'bg-green-500');
                    bars[i].classList.add('bg-blue-500');
                 }
             }
        }

        // 6. Sorting Algorithms (More robust forceStop checks and redraws)
        const checkStop = () => { if (forceStop) throw new Error('Algorithm stopped'); }

        // Redraw based on current state, apply highlights
         const redrawSortingBars = (highlights = {}) => {
            // Determine if labels should be shown
            const showLabels = customArraySorting.value.trim() !== '' || sortingArray.length <= 40;
            drawArray(sortingArray, visualizerSorting, showLabels);
            
            const bars = visualizerSorting.getElementsByClassName('sort-bar');
            
            // Apply green to sorted sections (important for merge/quick sort)
             // This needs more context from the specific algorithm steps

            // Apply highlights
            Object.entries(highlights).forEach(([index, color]) => {
                if (bars[index]) {
                    bars[index].classList.remove('bg-blue-500', 'bg-green-500', 'bg-gray-600'); // Remove base/other status colors
                    bars[index].classList.add(color); // Add the highlight color
                }
            });
        }
        
       const bubbleSort = async (bars) => {
            let n = sortingArray.length;
            let sortedCount = 0; // Keep track of sorted elements from the end
            for (let i = 0; i < n - 1; i++) {
                let swapped = false;
                for (let j = 0; j < n - i - 1; j++) {
                    checkStop();
                    // Redraw with current highlights + green for already sorted
                    let currentHighlights = { [j]: 'bg-red-500', [j + 1]: 'bg-red-500' };
                    for(let k = 0; k < sortedCount; k++) currentHighlights[n - 1 - k] = 'bg-green-500';
                    redrawSortingBars(currentHighlights);
                    await sleep(sortSpeed);
                    checkStop();

                    if (sortingArray[j] > sortingArray[j + 1]) {
                        [sortingArray[j], sortingArray[j + 1]] = [sortingArray[j + 1], sortingArray[j]];
                        swapped = true;
                        // Redraw after swap, highlight swapped elements
                        currentHighlights = { [j]: 'bg-yellow-500', [j + 1]: 'bg-yellow-500' };
                        for(let k = 0; k < sortedCount; k++) currentHighlights[n - 1 - k] = 'bg-green-500';
                        redrawSortingBars(currentHighlights); 
                        await sleep(sortSpeed);
                        checkStop();
                    }
                }
                sortedCount++; // One more element is sorted at the end
                 // Redraw to clear inner loop highlights and mark newly sorted element green
                 let finalHighlights = {};
                 for(let k = 0; k < sortedCount; k++) finalHighlights[n - 1 - k] = 'bg-green-500';
                 redrawSortingBars(finalHighlights); 
                 await sleep(sortSpeed / 2); // Short pause showing sorted state

                 if (!swapped) break; // Optimization
            }
            // Ensure all elements are green if loop finishes early or normally
             if (!forceStop) {
                 let finalHighlights = {};
                 for(let k = 0; k < n; k++) finalHighlights[k] = 'bg-green-500';
                 redrawSortingBars(finalHighlights);
            }
        };


       const insertionSort = async (bars) => {
            let n = sortingArray.length;
             // Mark first element as initially sorted
             redrawSortingBars({ [0]: 'bg-green-500' });
             await sleep(sortSpeed/2);

            for (let i = 1; i < n; i++) {
                checkStop();
                let key = sortingArray[i];
                let j = i - 1;
                
                // Highlight key and already sorted section
                let highlights = { [i]: 'bg-red-500' }; 
                for(let k=0; k < i; k++) highlights[k] = 'bg-green-500';
                redrawSortingBars(highlights);
                await sleep(sortSpeed);
                checkStop();

                // Shift elements greater than key
                while (j >= 0 && sortingArray[j] > key) {
                    checkStop();
                    sortingArray[j + 1] = sortingArray[j];
                    
                    // Highlight key, shifted element, and sorted section
                    highlights = { [i]: 'bg-red-500', [j]: 'bg-yellow-500', [j+1]: 'bg-yellow-500' };
                    for(let k=0; k < j; k++) highlights[k] = 'bg-green-500'; // Update sorted section boundary
                    redrawSortingBars(highlights);
                    
                    j = j - 1;
                    await sleep(sortSpeed);
                    checkStop();
                }
                // Place key in correct position
                sortingArray[j + 1] = key;

                // Redraw with key placed and mark entire section green
                 highlights = {};
                 for(let k=0; k <= i; k++) highlights[k] = 'bg-green-500';
                 redrawSortingBars(highlights);
                 await sleep(sortSpeed);
                 checkStop();
            }
             // Final green sweep (might be redundant but ensures correctness)
             if (!forceStop) {
                 let finalHighlights = {};
                 for(let k = 0; k < n; k++) finalHighlights[k] = 'bg-green-500';
                 redrawSortingBars(finalHighlights);
            }
        };


        const selectionSort = async (bars) => {
            let n = sortingArray.length;
            let sortedCount = 0;
            for (let i = 0; i < n - 1; i++) {
                checkStop();
                let minIdx = i;
                
                // Highlight sorted section + current position i
                let highlights = { [i]: 'bg-purple-500' }; 
                for(let k=0; k < sortedCount; k++) highlights[k] = 'bg-green-500';
                redrawSortingBars(highlights); 
                await sleep(sortSpeed/2); 
                checkStop();

                // Find minimum in unsorted part
                for (let j = i + 1; j < n; j++) {
                    checkStop();
                    // Highlight sorted, current pos i, comparison j, current minIdx
                    highlights = { [i]: 'bg-purple-500', [j]: 'bg-red-500', [minIdx]: 'bg-yellow-500' };
                    for(let k=0; k < sortedCount; k++) highlights[k] = 'bg-green-500';
                    redrawSortingBars(highlights);
                    await sleep(sortSpeed);
                    checkStop();

                    if (sortingArray[j] < sortingArray[minIdx]) {
                        minIdx = j;
                        // Update highlights immediately after finding new min
                        highlights = { [i]: 'bg-purple-500', [j]: 'bg-red-500', [minIdx]: 'bg-yellow-500' };
                        for(let k=0; k < sortedCount; k++) highlights[k] = 'bg-green-500';
                        redrawSortingBars(highlights);
                        await sleep(sortSpeed/2); 
                        checkStop();
                    }
                }
                
                // Swap if minimum is not the current element i
                if (minIdx !== i) {
                     // Highlight elements being swapped
                    highlights = { [i]: 'bg-orange-500', [minIdx]: 'bg-orange-500' }; // Use orange for swap
                    for(let k=0; k < sortedCount; k++) highlights[k] = 'bg-green-500';
                    redrawSortingBars(highlights);
                    await sleep(sortSpeed);
                    checkStop();

                    [sortingArray[i], sortingArray[minIdx]] = [sortingArray[minIdx], sortingArray[i]];
                }
                
                sortedCount++;
                // Redraw with the new element marked green
                highlights = {};
                 for(let k=0; k < sortedCount; k++) highlights[k] = 'bg-green-500';
                 redrawSortingBars(highlights); 
                await sleep(sortSpeed);
                checkStop();
            }
             // Ensure all are green at the end
             if (!forceStop) {
                 let finalHighlights = {};
                 for(let k = 0; k < n; k++) finalHighlights[k] = 'bg-green-500';
                 redrawSortingBars(finalHighlights);
            }
        };


       const heapSort = async (bars) => {
            let n = sortingArray.length;
            let sortedCount = 0; // Track sorted elements from the end
            checkStop();

            // Build max heap (elements not marked green yet)
            redrawSortingBars(); // Initial state
            for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                checkStop();
                await heapify(bars, n, i, sortedCount); // Pass sortedCount for highlighting
            }

            // Extract elements
            for (let i = n - 1; i > 0; i--) {
                checkStop();
                // Highlight swap (root and last unsorted element) + sorted elements
                let highlights = { [0]: 'bg-red-500', [i]: 'bg-red-500' };
                 for(let k = 0; k < sortedCount; k++) highlights[n - 1 - k] = 'bg-green-500';
                 redrawSortingBars(highlights);
                await sleep(sortSpeed);
                checkStop();

                [sortingArray[0], sortingArray[i]] = [sortingArray[i], sortingArray[0]];
                sortedCount++; // Increment sorted count
                
                // Redraw: mark newly sorted element green
                 highlights = {};
                 for(let k = 0; k < sortedCount; k++) highlights[n - 1 - k] = 'bg-green-500';
                 redrawSortingBars(highlights); 
                await sleep(sortSpeed);
                checkStop();

                // Heapify the reduced heap (size i), pass sortedCount
                await heapify(bars, i, 0, sortedCount); 
            }
             // Ensure all are marked green at the end
            if (!forceStop) {
                 let finalHighlights = {};
                 for(let k = 0; k < n; k++) finalHighlights[k] = 'bg-green-500';
                 redrawSortingBars(finalHighlights);
            }
        };

        const heapify = async (bars, heapSize, rootIndex, sortedCount) => {
            checkStop();
            let largest = rootIndex; 
            let leftChild = 2 * rootIndex + 1;
            let rightChild = 2 * rootIndex + 2;
            let n = sortingArray.length; // Total array length for green highlighting
            
            // Prepare highlights: green for sorted, red for root, yellow for children (if in heap)
            let highlights = { [rootIndex]: 'bg-red-500' };
            if (leftChild < heapSize) highlights[leftChild] = 'bg-yellow-500';
            if (rightChild < heapSize) highlights[rightChild] = 'bg-yellow-500';
            for(let k = 0; k < sortedCount; k++) highlights[n - 1 - k] = 'bg-green-500';
            redrawSortingBars(highlights);
            await sleep(sortSpeed);
            checkStop();

            // Find largest among root, left child, right child (within heap bounds)
            if (leftChild < heapSize && sortingArray[leftChild] > sortingArray[largest]) largest = leftChild;
            if (rightChild < heapSize && sortingArray[rightChild] > sortingArray[largest]) largest = rightChild;

            // If largest is not root
            if (largest !== rootIndex) {
                 // Highlight swap elements
                 highlights[rootIndex] = 'bg-purple-500'; 
                 highlights[largest] = 'bg-purple-500';
                 redrawSortingBars(highlights);
                 await sleep(sortSpeed);
                 checkStop();

                [sortingArray[rootIndex], sortingArray[largest]] = [sortingArray[largest], sortingArray[rootIndex]];
                
                // Redraw after swap, keeping sorted elements green
                highlights = {};
                 for(let k = 0; k < sortedCount; k++) highlights[n - 1 - k] = 'bg-green-500';
                 redrawSortingBars(highlights);
                await sleep(sortSpeed);
                checkStop();

                // Recursively heapify the affected sub-tree
                await heapify(bars, heapSize, largest, sortedCount); 
            }
             // No explicit redraw needed here if largest === rootIndex, next step will redraw
        };

       const mergeSort = async (bars, left, right) => {
            checkStop();
            if (left >= right) {
                 // Mark single element subarray as 'sorted' within its range (optional visual cue)
                 // redrawSortingBars({ [left]: 'bg-gray-500' }); 
                 // await sleep(sortSpeed/4);
                return; 
            }
            
            const mid = Math.floor((left + right) / 2);
            
             // Create promises for recursive calls
            const leftPromise = mergeSort(bars, left, mid);
            const rightPromise = mergeSort(bars, mid + 1, right);

            // Wait for both subarrays to be sorted conceptually
            await Promise.all([leftPromise, rightPromise]);
            checkStop(); // Check stop after recursive calls return

             // Visually indicate merging process
             let mergeHighlights = {};
             for(let k=left; k<=right; k++) mergeHighlights[k] = 'bg-gray-600'; // Dim the range to be merged
             redrawSortingBars(mergeHighlights);
             await sleep(sortSpeed/2);
             checkStop();

            // Perform the merge operation
            await merge(bars, left, mid, right);
             checkStop(); // Check stop after merge completes

              // Mark the newly merged range green if it's the final merge
            if (left === 0 && right === sortingArray.length - 1 && !forceStop) {
                 let finalHighlights = {};
                 for(let k=left; k<=right; k++) finalHighlights[k] = 'bg-green-500';
                 redrawSortingBars(finalHighlights);
                 await sleep(sortSpeed/2);
            } else if (!forceStop) {
                // Optionally highlight the merged subarray briefly to show it's sorted locally
                 let mergedHighlights = {};
                 for(let k=left; k<=right; k++) mergedHighlights[k] = 'bg-indigo-500'; // Example: Indigo color
                 redrawSortingBars(mergedHighlights);
                 await sleep(sortSpeed/2);
                 redrawSortingBars(); // Reset color
            }
        };
        
        const merge = async (bars, left, mid, right) => {
             // --- Merge logic remains largely the same ---
             // Key changes: Use redrawSortingBars with appropriate highlights.
            checkStop();
            let n1 = mid - left + 1;
            let n2 = right - mid;
            let L = new Array(n1);
            let R = new Array(n2);
            for (let i = 0; i < n1; i++) L[i] = sortingArray[left + i];
            for (let j = 0; j < n2; j++) R[j] = sortingArray[mid + 1 + j];

            let i = 0, j = 0, k = left; 

            while (i < n1 && j < n2) {
                checkStop();
                // Highlight comparison + dimmed merge range
                let highlights = {};
                for(let h=left; h<=right; h++) highlights[h] = 'bg-gray-600'; 
                highlights[left + i] = 'bg-red-500';
                highlights[mid + 1 + j] = 'bg-red-500';
                redrawSortingBars(highlights);
                await sleep(sortSpeed);
                checkStop();

                if (L[i] <= R[j]) {
                    sortingArray[k] = L[i]; i++;
                } else {
                    sortingArray[k] = R[j]; j++;
                }
                // Highlight placement
                highlights[k] = 'bg-yellow-500';
                redrawSortingBars(highlights);
                await sleep(sortSpeed); checkStop();
                k++;
            }

            // Copy remaining L[]
            while (i < n1) {
                checkStop();
                 let highlights = {}; // Reset highlights for this step
                 for(let h=left; h<=right; h++) highlights[h] = 'bg-gray-600'; 
                 highlights[left + i] = 'bg-red-500'; // Highlight element being copied
                 redrawSortingBars(highlights);
                 await sleep(sortSpeed); checkStop();

                sortingArray[k] = L[i];
                 highlights[k] = 'bg-yellow-500'; // Highlight placement
                 redrawSortingBars(highlights);
                 await sleep(sortSpeed); checkStop();
                i++; k++;
            }

            // Copy remaining R[]
            while (j < n2) {
                checkStop();
                 let highlights = {}; // Reset highlights for this step
                 for(let h=left; h<=right; h++) highlights[h] = 'bg-gray-600'; 
                 highlights[mid + 1 + j] = 'bg-red-500'; // Highlight element being copied
                 redrawSortingBars(highlights);
                 await sleep(sortSpeed); checkStop();

                sortingArray[k] = R[j];
                 highlights[k] = 'bg-yellow-500'; // Highlight placement
                 redrawSortingBars(highlights);
                 await sleep(sortSpeed); checkStop();
                j++; k++;
            }
            // No final redraw here, handled by mergeSort caller
        };

        const quickSort = async (bars, low, high) => {
            checkStop();
             // Base case: If subarray is invalid or has 0/1 elements
             if (low >= high || low < 0) {
                 // Mark valid single elements green
                if (low === high && low >= 0 && low < sortingArray.length) {
                     redrawSortingBars({ [low]: 'bg-green-500' });
                     await sleep(sortSpeed/4); // Very short pause
                 }
                return; 
            }

            let pi = await partition(bars, low, high);
            checkStop();

             // Mark pivot green AFTER partition completes and returns index pi
             redrawSortingBars({ [pi]: 'bg-green-500' });
             await sleep(sortSpeed / 2); // Pause to show pivot finalized
             checkStop();

            // Recursively sort elements before and after partition
            await quickSort(bars, low, pi - 1);
            checkStop();
            await quickSort(bars, pi + 1, high);
        };
        
       const partition = async (bars, low, high) => {
            checkStop();
            let pivot = sortingArray[high]; 
            let i = low - 1; // Index of smaller element boundary

            // Initial highlight: Pivot yellow, range gray
            let highlights = { [high]: 'bg-yellow-500' };
            for(let k=low; k<high; k++) highlights[k] = 'bg-gray-600';
            redrawSortingBars(highlights);
            await sleep(sortSpeed);
            checkStop();

            for (let j = low; j < high; j++) {
                checkStop();
                 // Highlight j (current comparison) red
                 highlights[j] = 'bg-red-500'; 
                 // Keep pivot yellow, others gray
                 redrawSortingBars(highlights);
                 await sleep(sortSpeed);
                 checkStop();

                if (sortingArray[j] < pivot) {
                    i++; // Increment boundary of smaller elements
                    
                     // Highlight i and j for swap (purple)
                     highlights[i] = 'bg-purple-500'; 
                     highlights[j] = 'bg-purple-500'; 
                     redrawSortingBars(highlights);
                     await sleep(sortSpeed);
                     checkStop();

                    // Swap arr[i] and arr[j]
                    [sortingArray[i], sortingArray[j]] = [sortingArray[j], sortingArray[i]];

                    // Redraw after swap: Reset swapped elements to gray, keep pivot yellow
                    highlights[i] = 'bg-gray-600'; 
                    highlights[j] = 'bg-gray-600'; // j will be highlighted red again in next loop iter
                    redrawSortingBars(highlights);
                     await sleep(sortSpeed/2); // Shorter pause after swap redraw
                     checkStop();
                } else {
                     // If no swap, reset j to gray before next iteration
                     highlights[j] = 'bg-gray-600';
                     // No sleep needed here, next iteration handles highlight
                }
            }

            // Final swap: Place pivot (arr[high]) at arr[i+1]
             checkStop();
             // Highlight pivot and destination for final swap
             highlights = { [i + 1]: 'bg-purple-500', [high]: 'bg-purple-500' };
             redrawSortingBars(highlights);
             await sleep(sortSpeed);
             checkStop();

            [sortingArray[i + 1], sortingArray[high]] = [sortingArray[high], sortingArray[i + 1]];
            
            // Redraw one last time for this partition, pivot placement doesn't need highlight here
            // The green marking is done in quickSort AFTER partition returns
             redrawSortingBars(); 
             await sleep(sortSpeed/2); 
             checkStop();

            return i + 1; // Return the partition index
        };


        // --- SEARCHING ALGORITHM LOGIC ---
        // ... (startSearching, linearSearch, binarySearch mostly same, added redrawSortingBars calls) ...
         const startSearching = async () => {
            const target = parseInt(targetInputSearching.value, 10);
            if (isNaN(target)) {
                console.error("Please enter a valid number as target.");
                targetInputSearching.value = "ERROR: Invalid Target";
                return;
            }
            
            // Ensure array exists, try custom first, then random
            if (searchingArray.length === 0) {
                 useCustomArray(true);
                 if (searchingArray.length === 0) generateArray(true);
            }
             if (searchingArray.length === 0) return; // Still no array, exit

            disableControls('searching');
            currentAlgorithmExecution = null; // Reset execution holder
            const bars = visualizerSearching.getElementsByClassName('sort-bar');
            let found = false;
            
            // Reset bar colors before starting
            drawArray(searchingArray, visualizerSearching, true); // Use searchingArray and visualizerSearching
            await sleep(50); // Short pause to render reset colors

            try {
                if (currentSearchingAlgorithm === 'linearSearch') {
                    // Linear search works on unsorted, ensure it's not accidentally sorted FOR RANDOM ONLY
                    const isSorted = searchingArray.every((v, i, a) => !i || a[i-1] <= v);
                    // Only shuffle if it's a random array (no custom input) AND it happens to be sorted
                    if (isSorted && searchingArray.length > 1 && customArraySearching.value.trim() === '') { 
                        console.log("Shuffling random array for Linear Search visualization");
                        searchingArray.sort(() => Math.random() - 0.5); 
                        drawArray(searchingArray, visualizerSearching, true);
                        await sleep(100);
                    }
                    currentAlgorithmExecution = linearSearch;
                    found = await linearSearch(bars, target);

                } else if (currentSearchingAlgorithm === 'binarySearch') {
                    // Binary search requires sorted array
                    const isSorted = searchingArray.every((v, i, a) => !i || a[i-1] <= v);
                    if (!isSorted) {
                        console.log("Sorting array for Binary Search visualization");
                        searchingArray.sort((a,b) => a-b);
                        drawArray(searchingArray, visualizerSearching, true);
                        // Visual indication of sorting
                         resetBarColors(bars); // Reset first
                         for(let i=0; i< bars.length; i++) {
                             if(bars[i]) bars[i].classList.replace('bg-blue-500', 'bg-yellow-500');
                             await sleep(10); // Quick sort indication
                         }
                        await sleep(200);
                        drawArray(searchingArray, visualizerSearching, true); // redraw with normal color
                        await sleep(100);
                    }
                    currentAlgorithmExecution = binarySearch;
                    found = await binarySearch(bars, target);
                }
            } catch (error) {
                 if (error.message === 'Algorithm stopped') {
                    console.log('Searching stopped by user.');
                } else {
                    console.error('Error during searching:', error);
                }
            } finally {
                if (forceStop && !found) { // Only reset if stopped AND not found yet
                     // Reset colors if stopped
                     drawArray(searchingArray, visualizerSearching, true);
                }
                console.log("Search finished. Found:", found);
                enableControls('searching');
                currentAlgorithmExecution = null;
            }
        };

        const linearSearch = async (bars, target) => {
            for (let i = 0; i < bars.length; i++) {
                checkStop();
                if(!bars[i]) continue; 
                resetBarColors(bars); // Reset previous highlights
                bars[i].classList.replace('bg-blue-500', 'bg-red-500'); 
                await sleep(sortSpeed);
                checkStop();

                if (searchingArray[i] === target) {
                    bars[i].classList.replace('bg-red-500','bg-green-500');
                    return true; // Found
                }
                // Keep red until next iteration resets it
                // Optional: mark as gray after check?
                 bars[i].classList.replace('bg-red-500', 'bg-gray-600'); 
            }
             resetBarColors(bars); // Reset if not found
            return false; // Not found
        };

        const binarySearch = async (bars, target) => {
            let low = 0;
            let high = searchingArray.length - 1;

            while (low <= high) {
                checkStop();
                let mid = Math.floor((low + high) / 2);
                
                // Reset colors before applying new highlights
                 resetBarColors(bars); 
                // Highlight range yellow, mid red
                 for(let i=low; i<=high; i++) {
                     if(bars[i]) bars[i].classList.replace('bg-blue-500', 'bg-yellow-500');
                 }
                if(bars[mid]) bars[mid].classList.replace('bg-yellow-500', 'bg-red-500'); 

                await sleep(sortSpeed * 1.5); // Slightly slower for binary search
                checkStop();

                if (searchingArray[mid] === target) {
                    if(bars[mid]) bars[mid].classList.replace('bg-red-500', 'bg-green-500');
                     // Clear yellow range highlight
                     for(let i=low; i<=high; i++) {
                          if(bars[i] && i !== mid) bars[i].classList.replace('bg-yellow-500', 'bg-blue-500');
                     }
                    return true; // Found
                }
                
                // Mark discarded sections gray BEFORE adjusting low/high
                if (searchingArray[mid] < target) {
                     for(let i=low; i<=mid; i++){ // Mark left side (including mid) gray
                         if(bars[i]) bars[i].classList.replace('bg-red-500','bg-gray-600').replace('bg-yellow-500','bg-gray-600');
                     }
                    low = mid + 1;
                } else {
                     for(let i=mid; i<=high; i++){ // Mark right side (including mid) gray
                          if(bars[i]) bars[i].classList.replace('bg-red-500','bg-gray-600').replace('bg-yellow-500','bg-gray-600');
                     }
                    high = mid - 1;
                }
                 await sleep(sortSpeed); // Pause after marking gray
            }
             // Clear all highlights if not found
             resetBarColors(bars);
            return false; // Not found
        };


        // --- PATHFINDING ALGORITHM LOGIC ---

        // --- PATHFINDING HELPER FUNCTIONS (Define BEFORE Node class) ---
        const resetGrid = () => { // Moved definition up
            if (isPathfinding) stopAlgorithm();
            grid.forEach(row => row.forEach(node => {
                node.isWall = false;
                node.isVisited = false;
                node.distance = Infinity;
                node.f = Infinity;
                node.h = Infinity;
                node.previousNode = null;
                node.domElement.classList.remove('wall', 'visited', 'path');
                node.isStart = node.row === startNode.row && node.col === startNode.col;
                node.isEnd = node.row === endNode.row && node.col === endNode.col;
                node.domElement.classList.toggle('start', node.isStart);
                node.domElement.classList.toggle('end', node.isEnd);
                node.domElement.style.cursor = node.isStart || node.isEnd ? 'grab' : 'pointer';
            }));
        };

        const clearSearch = () => { // Moved definition up
             if (isPathfinding) stopAlgorithm(); 
             console.log("Clearing search path and visited nodes");
             grid.forEach(row => row.forEach(node => {
                node.isVisited = false; 
                node.distance = Infinity;
                node.f = Infinity;
                node.h = Infinity;
                node.previousNode = null;
                if (!node.isStart && !node.isEnd && !node.isWall) {
                     node.domElement.classList.remove('visited', 'path');
                     node.domElement.style.backgroundColor = ''; 
                }
            }));
        };

        const handleMouseDown = (row, col) => { // Moved definition up
            if (isPathfinding) return;
            row = parseInt(row, 10); col = parseInt(col, 10); // Ensure numbers
             if (isNaN(row) || isNaN(col) || !grid[row]?.[col]) return; // Check validity

            const node = grid[row][col];
            if (node.isStart) {
                isMovingStart = true;
                 gridContainer.style.cursor = 'grabbing';
            } else if (node.isEnd) {
                isMovingEnd = true;
                 gridContainer.style.cursor = 'grabbing';
            } else {
                isDrawingWalls = true;
                node.isWall = !node.isWall; 
                node.domElement.classList.toggle('wall', node.isWall);
                clearSearch(); // Clear path if walls are changed
            }
        };
        
        const handleMouseEnter = (row, col) => { // Moved definition up
            if (isPathfinding) return;
            row = parseInt(row, 10); col = parseInt(col, 10);
            if (isNaN(row) || isNaN(col) || row < 0 || row >= GRID_ROWS || col < 0 || col >= GRID_COLS || !grid[row]?.[col]) return; 

            const node = grid[row][col];

            if (isDrawingWalls) {
                if (!node.isStart && !node.isEnd) {
                    if (!node.isWall) { 
                         node.isWall = true;
                         node.domElement.classList.add('wall');
                         clearSearch(); 
                    }
                }
            } else if (isMovingStart) {
                 if (!node.isWall && !node.isEnd && !(node.row === startNode.row && node.col === startNode.col)) { // Prevent self-move flicker
                     grid[startNode.row][startNode.col].isStart = false;
                     grid[startNode.row][startNode.col].domElement.classList.remove('start');
                     grid[startNode.row][startNode.col].domElement.style.cursor = 'pointer'; 
                     
                     startNode = { row, col };
                     node.isStart = true;
                     node.domElement.classList.add('start');
                     node.domElement.style.cursor = 'grab';
                     clearSearch(); 
                 }
            } else if (isMovingEnd) {
                 if (!node.isWall && !node.isStart && !(node.row === endNode.row && node.col === endNode.col)) { // Prevent self-move flicker
                     grid[endNode.row][endNode.col].isEnd = false;
                     grid[endNode.row][endNode.col].domElement.classList.remove('end');
                     grid[endNode.row][endNode.col].domElement.style.cursor = 'pointer';

                     endNode = { row, col };
                     node.isEnd = true;
                     node.domElement.classList.add('end');
                      node.domElement.style.cursor = 'grab';
                     clearSearch(); 
                 }
            }
        };
        
        const handleMouseUp = () => { // Moved definition up (Global handler)
             if (isDrawingWalls || isMovingStart || isMovingEnd) {
                isDrawingWalls = false;
                isMovingStart = false;
                isMovingEnd = false;
                 gridContainer.style.cursor = 'default';
                 // Ensure start/end nodes retain 'grab' cursor
                 if(grid[startNode.row]?.[startNode.col]) grid[startNode.row][startNode.col].domElement.style.cursor = 'grab';
                  if(grid[endNode.row]?.[endNode.col]) grid[endNode.row][endNode.col].domElement.style.cursor = 'grab';
            }
        };

        const getAllNodes = () => { // Moved definition up
            const nodes = [];
            for (const row of grid) {
                for (const node of row) {
                    nodes.push(node);
                }
            }
            return nodes;
        };

        const getNeighbors = (node) => { // Moved definition up
            const neighbors = [];
            const { row, col } = node;
            if (row > 0 && grid[row-1]?.[col]) neighbors.push(grid[row - 1][col]);
            if (row < GRID_ROWS - 1 && grid[row+1]?.[col]) neighbors.push(grid[row + 1][col]);
            if (col > 0 && grid[row]?.[col-1]) neighbors.push(grid[row][col - 1]);
            if (col < GRID_COLS - 1 && grid[row]?.[col+1]) neighbors.push(grid[row][col + 1]);
            return neighbors;
        };
       
        const heuristic = (nodeA, nodeB) => { // Moved definition up
            const dRow = Math.abs(nodeA.row - nodeB.row);
            const dCol = Math.abs(nodeA.col - nodeB.col);
            return dRow + dCol; // Manhattan distance
        };

        const animateShortestPath = async (endNode) => { // Moved definition up
            let currentNode = endNode;
            const path = [];
            while(currentNode !== null) { 
                path.push(currentNode);
                if(path.length > GRID_ROWS * GRID_COLS) {
                    console.error("Path reconstruction loop."); break; 
                }
                currentNode = currentNode.previousNode;
            }
            path.reverse();
            
            for (const node of path) {
                 checkStop(); // Check before animation step
                if (!node.isStart && !node.isEnd) {
                    node.domElement.classList.remove('visited'); 
                    node.domElement.classList.add('path');
                     checkStop(); // Check before sleep
                     await sleep(25); 
                }
            }
        };


        // 1. Node class (Defined AFTER helper functions it uses)
        class Node {
             constructor(row, col) {
                this.row = row;
                this.col = col;
                this.isStart = row === startNode.row && col === startNode.col;
                this.isEnd = row === endNode.row && col === endNode.col;
                this.isWall = false;
                this.isVisited = false; 
                this.distance = Infinity; 
                this.f = Infinity; 
                this.h = Infinity; 
                this.previousNode = null;
                this.domElement = document.createElement('div');
                this.domElement.classList.add('grid-cell');
                this.domElement.dataset.row = row;
                this.domElement.dataset.col = col;
                if (this.isStart) this.domElement.classList.add('start');
                if (this.isEnd) this.domElement.classList.add('end');
                
                // Add event listeners - functions are now defined above
                this.domElement.addEventListener('mousedown', (e) => { e.preventDefault(); handleMouseDown(row, col); });
                this.domElement.addEventListener('mouseenter', (e) => { e.preventDefault(); handleMouseEnter(row, col); });
                // Mouseup is handled globally on body
                this.domElement.addEventListener('touchstart', (e) => { e.preventDefault(); handleMouseDown(row, col); });
                this.domElement.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const element = document.elementFromPoint(touch.clientX, touch.clientY); 
                    if(element && element.classList.contains('grid-cell')) {
                        const touchRow = parseInt(element.dataset.row, 10);
                        const touchCol = parseInt(element.dataset.col, 10);
                         if(element !== e.target) { 
                           handleMouseEnter(touchRow, touchCol);
                        }
                    }
                });
                // Touchend is handled globally on body
            }
        }
        
        // 2. Create Grid (Can now use the Node class)
        const createGrid = () => {
            if (isPathfinding) return;
            grid = [];
            gridContainer.innerHTML = '';
            gridContainer.style.gridTemplateColumns = `repeat(${GRID_COLS}, 1fr)`;
            
            for (let r = 0; r < GRID_ROWS; r++) {
                const row = [];
                for (let c = 0; c < GRID_COLS; c++) {
                    const node = new Node(r, c); // Node class is defined now
                    row.push(node);
                    gridContainer.appendChild(node.domElement);
                }
                grid.push(row);
            }
        };

        // ... (Remaining pathfinding algorithms: startPathfinding, dijkstra, aStar, bfs, dfs) ...
         // 6. Start Pathfinding
        const startPathfinding = async () => {
            disableControls('pathfinding');
            clearSearch(); // Clear previous path/visited nodes
            await sleep(50); // Short delay to allow UI to clear

            const start = grid[startNode.row]?.[startNode.col]; // Add safety checks
            const end = grid[endNode.row]?.[endNode.col];

             if (!start || !end) {
                 console.error("Start or End node is missing or invalid.");
                 enableControls('pathfinding');
                 return;
             }
            
            let found = false;
            currentAlgorithmExecution = null; // Reset execution holder
            try {
                switch (currentPathfindingAlgorithm) {
                    case 'dijkstra': currentAlgorithmExecution = dijkstra; found = await dijkstra(start, end); break;
                    case 'aStar': currentAlgorithmExecution = aStar; found = await aStar(start, end); break;
                    case 'bfs': currentAlgorithmExecution = bfs; found = await bfs(start, end); break;
                    case 'dfs': currentAlgorithmExecution = dfs; found = await dfs(start, end); break;
                }
             } catch (error) {
                 if (error.message === 'Algorithm stopped') {
                    console.log('Pathfinding stopped by user.');
                } else {
                    console.error('Error during pathfinding:', error);
                }
                 found = false; // Ensure found is false if stopped or error occurs
            } finally {
                 if (forceStop) {
                     // Optionally clear again if stopped halfway
                     // clearSearch(); 
                 } else if (found) {
                    await animateShortestPath(end);
                } else if (!forceStop) { // Only log "not found" if not stopped
                    console.log("No path found");
                    // Add user feedback here if desired (e.g., a message)
                }
                
                enableControls('pathfinding');
                currentAlgorithmExecution = null;
            }
        };
        
        // 7. Pathfinding Algorithms (Ensure checkStop is called within loops)
        const dijkstra = async (start, end) => {
            const nodes = getAllNodes(); 
            nodes.forEach(node => { node.distance = Infinity; node.previousNode = null; node.isVisited = false; }); 
            start.distance = 0;
            const priorityQueue = [start]; 

            while(priorityQueue.length > 0) {
                 checkStop(); 
                 priorityQueue.sort((a, b) => a.distance - b.distance); 
                 const closestNode = priorityQueue.shift();
                 
                 if (closestNode.isVisited || closestNode.isWall) continue; 
                 
                 closestNode.isVisited = true;
                 if (!closestNode.isStart && !closestNode.isEnd) {
                     closestNode.domElement.classList.add('visited');
                 }
                 checkStop(); 
                 await sleep(5); 

                 if (closestNode === end) return true; 
                 
                 const neighbors = getNeighbors(closestNode); 
                 for(const neighbor of neighbors){
                     // No need to check isVisited here for Dijkstra's core logic,
                     // but check wall
                     if(neighbor.isWall) continue; 

                     const distanceThroughCurrent = closestNode.distance + 1; 
                     if(distanceThroughCurrent < neighbor.distance){
                         neighbor.distance = distanceThroughCurrent;
                         neighbor.previousNode = closestNode;
                         
                          // Add to queue (or update priority in a real PQ)
                          // Only add if not effectively 'closed' (isVisited check here prevents re-adding closed nodes)
                         if (!neighbor.isVisited) { 
                             if (!priorityQueue.some(n => n === neighbor)) {
                                   priorityQueue.push(neighbor);
                              }
                         }
                     }
                 }
            }
            return false; 
        };

         const aStar = async (start, end) => {
            const openSet = [start]; 
            const nodes = getAllNodes();
             nodes.forEach(node => { 
                node.distance = Infinity; node.f = Infinity; node.h = Infinity; 
                node.previousNode = null; node.isVisited = false; 
            }); 
            
            start.distance = 0; 
            start.h = heuristic(start, end);
            start.f = start.h; 

            while (openSet.length > 0) {
                 checkStop(); 
                 
                openSet.sort((a, b) => a.f - b.f);
                const currentNode = openSet.shift(); 

                if (currentNode === end) return true; 

                // Process node only once (effectively the closed set)
                 if (currentNode.isVisited || currentNode.isWall) continue; 
                 currentNode.isVisited = true; 

                if (!currentNode.isStart && !currentNode.isEnd) {
                    currentNode.domElement.classList.add('visited');
                }
                 checkStop(); 
                 await sleep(5);

                const neighbors = getNeighbors(currentNode); 
                for (const neighbor of neighbors) {
                    // Skip walls and already processed nodes
                    if (neighbor.isWall || neighbor.isVisited) continue; 

                    const tentativeGScore = currentNode.distance + 1; 

                    // Check if this path is better OR if neighbor hasn't been evaluated yet
                     let isInOpenSet = openSet.some(node => node === neighbor);
                    if (tentativeGScore < neighbor.distance) {
                        neighbor.previousNode = currentNode;
                        neighbor.distance = tentativeGScore; 
                        neighbor.h = heuristic(neighbor, end); 
                        neighbor.f = neighbor.distance + neighbor.h; 

                        if (!isInOpenSet) {
                            openSet.push(neighbor);
                        }
                         // If using a real PQ, update the node's priority here.
                    }
                }
            }
            return false; 
        };

         const bfs = async (start, end) => {
            const queue = [start];
             getAllNodes().forEach(node => { node.isVisited = false; node.previousNode = null; }); 
            start.isVisited = true; 
            
            while (queue.length > 0) {
                 checkStop(); 
                const currentNode = queue.shift();
                
                if (currentNode.isWall) continue;
                
                if (!currentNode.isStart && !currentNode.isEnd) {
                    currentNode.domElement.classList.add('visited');
                }
                 checkStop(); 
                 await sleep(5); 
                
                if (currentNode === end) return true; 
                
                const neighbors = getNeighbors(currentNode); 
                for (const neighbor of neighbors) {
                    if (!neighbor.isWall && !neighbor.isVisited) { 
                        neighbor.isVisited = true;
                        neighbor.previousNode = currentNode;
                        queue.push(neighbor);
                    }
                }
            }
            return false; 
        };

         const dfs = async (start, end) => {
            const stack = [start];
             getAllNodes().forEach(node => { node.isVisited = false; node.previousNode = null; }); 

            while (stack.length > 0) {
                 checkStop(); 
                const currentNode = stack.pop();
                
                 if (currentNode.isVisited || currentNode.isWall) continue; 
                
                currentNode.isVisited = true; 
                if (!currentNode.isStart && !currentNode.isEnd) {
                    currentNode.domElement.classList.add('visited');
                }
                 checkStop(); 
                 await sleep(5); 

                if (currentNode === end) return true; 
                
                const neighbors = getNeighbors(currentNode); // No need to reverse for correctness, just visual preference
                for (const neighbor of neighbors) {
                    if (!neighbor.isWall && !neighbor.isVisited) {
                        neighbor.previousNode = currentNode;
                        stack.push(neighbor); 
                    }
                }
            }
            return false; 
        };

        // --- DYNAMIC PROGRAMMING LOGIC ---
        // ... (startDP, visualizeFibonacci, placeholders remain the same) ...
        const startDP = async () => {
            disableControls('dp');
             dpOutputContainer.innerHTML = '<p class="text-yellow-400 animate-pulse">Calculating...</p>'; // Improved working message
            await sleep(50); // Allow UI update

            try {
                switch(currentDPAlgorithm) {
                    case 'fibonacci': await visualizeFibonacci(); break;
                    case 'knapsack': await visualizeKnapsack(); break; // Still placeholder
                    case 'lcs': await visualizeLCS(); break; // Still placeholder
                }
            } catch (error) {
                 if (error.message === 'Algorithm stopped') {
                    console.log('DP stopped by user.');
                     dpOutputContainer.innerHTML += '<p class="text-red-500 font-bold mt-4">STOPPED BY USER</p>';
                } else {
                    console.error('Error during DP:', error);
                     dpOutputContainer.innerHTML = `<p class="text-red-500 font-bold mt-4">An error occurred: ${error.message}</p>`;
                }
            } finally {
                enableControls('dp');
            }
        };
        
        const visualizeFibonacci = async () => {
            const nInput = document.getElementById('dp-fib-n');
            const n = parseInt(nInput.value, 10);
            
            // Input validation
            if (isNaN(n) || n < 0 || n > 90) { // Capped at 90
                dpOutputContainer.innerHTML = '<p class="text-red-500">Invalid input for n (must be 0-90).</p>';
                nInput.focus(); // Help user correct input
                return;
            }
            
            let memo = {}; // Use object for potentially sparse large numbers
            dpOutputContainer.innerHTML = `<h3 class="text-lg font-bold mb-2">Memoization Table (n=${n})</h3>`;
            const tableContainer = document.createElement('div');
             // Styling for the table container
            tableContainer.classList.add('flex', 'flex-wrap', 'gap-2', 'p-2', 'bg-gray-700', 'rounded-lg', 'justify-center'); 
            dpOutputContainer.appendChild(tableContainer);

            // Helper to create or update cell visually
            const updateCell = async (num, value, status) => {
                 checkStop();
                 let cell = tableContainer.querySelector(`[data-index='${num}']`);
                 if (!cell) {
                     cell = document.createElement('div');
                     cell.dataset.index = num;
                     // Base cell styling
                     cell.classList.add('p-2', 'bg-gray-600', 'rounded', 'font-mono', 'text-xs', 'min-w-[70px]', 'text-center', 'transition-colors', 'duration-150'); 
                     cell.innerHTML = `fib(${num}) = ?`;
                     // Insert in correct order if possible (simple append often okay)
                     tableContainer.appendChild(cell); 
                     await sleep(100); // Pause for cell creation
                 }
                 
                 cell.innerHTML = `fib(${num}) = ${value}`;
                 // Remove previous status colors
                 cell.classList.remove('bg-yellow-500', 'bg-blue-600', 'bg-green-600', 'bg-gray-600');
                 
                 switch(status) {
                     case 'computing': cell.classList.add('bg-blue-600', 'text-white'); break;
                     case 'memoized': cell.classList.add('bg-yellow-500', 'text-black'); break;
                     case 'done': cell.classList.add('bg-green-600', 'text-white'); break;
                     default: cell.classList.add('bg-gray-600'); // Default/Reset
                 }
                 await sleep(150); // Pause for status update
                 checkStop();
            }

            const fib = async (num) => {
                 checkStop();
                 if (num <= 1) {
                     if (memo[num] === undefined) { // Show base cases in table
                         await updateCell(num, num, 'done');
                         memo[num] = num;
                     }
                     return num;
                 }
                 
                // Check memo first
                if (memo[num] !== undefined) {
                    await updateCell(num, memo[num], 'memoized'); // Show memo hit
                    return memo[num];
                }

                 // If not in memo, compute
                 await updateCell(num, '...', 'computing'); // Show computing status

                 let res1 = await fib(num - 1);
                 checkStop(); 
                 let res2 = await fib(num - 2);
                 checkStop();
                 
                 // JS struggles with very large Fibonacci numbers, results might become inaccurate (Infinity)
                 let res = res1 + res2; 
                 memo[num] = res; // Store result
                 
                 await updateCell(num, res, 'done'); // Show final computed value
                 return res;
            };

            const result = await fib(n);
             checkStop(); // Final check before displaying result
            dpOutputContainer.innerHTML += `<h3 class="text-xl font-bold mt-4 text-center">Result: fib(${n}) = ${result}</h3>`;
             // Add brief explanation of visualization
             dpOutputContainer.innerHTML += `<div class="text-xs text-gray-400 mt-2 text-center">Blue: Computing | Yellow: Memoized value used | Green: Value computed & stored</div>`;
        };
        
         const visualizeKnapsack = async () => {
             dpOutputContainer.innerHTML = `
                <p class="text-gray-400">Knapsack visualization is complex and not yet implemented.</p>
                <p class="text-gray-500 text-sm">Future implementation would involve dynamically creating and filling a 2D grid (N x W) to show how the <code class="font-mono bg-gray-700 px-1 rounded">dp[i][w]</code> values are computed step-by-step, indicating whether an item is included or excluded at each stage.</p>
            `;
            console.log("Knapsack logic placeholder");
            for (let i=0; i<3; i++) { // Shorter simulated wait
                checkStop(); await sleep(100); 
            }
        };
        
        const visualizeLCS = async () => {
             dpOutputContainer.innerHTML = `
                <p class="text-gray-400">LCS visualization is complex and not yet implemented.</p>
                <p class="text-gray-500 text-sm">Future implementation would involve creating a 2D grid (M x N) for the two strings and animating the cell-by-cell comparison based on character matches to fill the <code class="font-mono bg-gray-700 px-1 rounded">dp[i][j]</code> table, potentially highlighting the path taken to reconstruct the LCS.</p>
            `;
            console.log("LCS logic placeholder");
             for (let i=0; i<3; i++) { // Shorter simulated wait
                checkStop(); await sleep(100); 
            }
        };


        // --- EVENT LISTENERS ---
        // ... (Event listeners remain mostly the same, ensure debounce is used correctly) ...
        window.addEventListener('DOMContentLoaded', () => {
            // Tabs
            tabSorting.addEventListener('click', () => switchView('sorting'));
            tabSearching.addEventListener('click', () => switchView('searching'));
            tabPathfinding.addEventListener('click', () => switchView('pathfinding'));
            tabDp.addEventListener('click', () => switchView('dp'));
            
            // Sorting Controls
            algoSelectSorting.addEventListener('change', (e) => {
                currentSortingAlgorithm = e.target.value;
                updateComplexityInfo();
            });
            speedSliderSorting.addEventListener('input', (e) => {
                sortSpeed = 510 - parseInt(e.target.value, 10); 
            });
             // Use 'change' event for slider size to generate only when user releases mouse
            sizeSliderSorting.addEventListener('change', (e) => { 
                 sortArraySize = parseInt(e.target.value, 10);
                 sizeLabelSorting.textContent = sortArraySize; 
                 generateArray(false); // Generate new array on size change completion
            });
             // Also update label on 'input' for immediate feedback
             sizeSliderSorting.addEventListener('input', (e) => {
                  sizeLabelSorting.textContent = e.target.value;
             });


            btnGenerateArray.addEventListener('click', () => generateArray(false));
            btnUseCustomArraySorting.addEventListener('click', () => useCustomArray(false));
            btnStartSorting.addEventListener('click', startSorting);
            btnStopSorting.addEventListener('click', stopAlgorithm);

            // Searching Controls
            algoSelectSearching.addEventListener('change', (e) => {
                currentSearchingAlgorithm = e.target.value;
                handleSearchArraySourceChange(true); 
                updateComplexityInfo();
            });
             // Use 'change' for search size slider too
             sizeSliderSearching.addEventListener('change', (e) => { 
                 searchArraySize = parseInt(e.target.value, 10);
                 sizeLabelSearching.textContent = searchArraySize; 
                 generateArray(true); 
            });
             // Update label on input
              sizeSliderSearching.addEventListener('input', (e) => {
                  sizeLabelSearching.textContent = e.target.value;
             });


            btnGenerateArraySearching.addEventListener('click', () => generateArray(true));
            btnUseCustomArraySearching.addEventListener('click', () => useCustomArray(true));
            btnStartSearching.addEventListener('click', startSearching);
            btnStopSearching.addEventListener('click', stopAlgorithm);
            
             // Helper to handle array regeneration/sorting when source/algo changes
            const handleSearchArraySourceChange = (isSearchTab) => {
                 const customInput = isSearchTab ? customArraySearching.value : customArraySorting.value;
                 if (customInput.trim() !== '' && !customInput.startsWith("ERROR:")) {
                     useCustomArray(isSearchTab); 
                 } else {
                     generateArray(isSearchTab); 
                 }
            }

            // Pathfinding Controls
            algoSelectPathfinding.addEventListener('change', (e) => {
                currentPathfindingAlgorithm = e.target.value;
                updateComplexityInfo();
                clearSearch(); 
            });
            btnResetGrid.addEventListener('click', resetGrid); // Event listener points to the function now defined above
            btnClearPath.addEventListener('click', clearSearch);
            btnStartPathfinding.addEventListener('click', startPathfinding);
            btnStopPathfinding.addEventListener('click', stopAlgorithm);

            // DP Controls
            algoSelectDp.addEventListener('change', updateDPInputs);
            btnStartDp.addEventListener('click', startDP);
            btnStopDp.addEventListener('click', stopAlgorithm);
            
            // Global mouse/touch up handlers
            document.body.addEventListener('mouseup', handleMouseUp);
            document.body.addEventListener('touchend', handleMouseUp);
            
            // Initial setup
            switchView('sorting'); 
        });

    </script>
</body>
</html>

