<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm Playground</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Load Inter font -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Sorting bar styles */
        .sort-bar {
            width: 100%;
            transition: height 0.3s ease, background-color 0.3s ease;
            margin: 0 1px;
            border-radius: 4px 4px 0 0;
            position: relative; /* Added for label positioning */
        }
        
        .sort-bar-label {
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            font-weight: 600;
            color: white;
            background-color: rgba(0,0,0,0.3);
            padding: 0 2px;
            border-radius: 2px;
            white-space: nowrap;
        }

        /* Pathfinding grid cell styles */
        .grid-cell {
            width: 100%;
            padding-bottom: 100%; /* Creates a perfect square aspect ratio */
            position: relative;
            border: 1px solid #374151; /* gray-700 */
            transition: background-color 0.1s ease, transform 0.2s ease;
        }
        
        .grid-cell.start { background-color: #10B981; } /* emerald-500 */
        .grid-cell.end { background-color: #EF4444; } /* red-500 */
        .grid-cell.wall { 
            background-color: #111827; /* gray-900 */
            transform: scale(0.9);
        }
        .grid-cell.visited { 
            background-color: #3B82F6; /* blue-500 */
            animation: pulse-visited 0.5s ease;
        }
        .grid-cell.path { 
            background-color: #F59E0B; /* amber-500 */
            animation: pulse-path 0.8s ease;
        }
        
        @keyframes pulse-visited {
            0% { transform: scale(0.7); border-radius: 50%; }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); border-radius: 0; }
        }
        @keyframes pulse-path {
            0% { transform: scale(0.7); }
            100% { transform: scale(1); }
        }

        /* Custom slider track */
        input[type="range"]::-webkit-slider-runnable-track {
            background: #374151; /* gray-700 */
            height: 8px;
            border-radius: 4px;
        }
        input[type="range"]::-moz-range-track {
            background: #374151; /* gray-700 */
            height: 8px;
            border-radius: 4px;
        }
        /* Custom slider thumb */
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3B82F6; /* blue-500 */
            cursor: pointer;
            margin-top: -6px; /* Center thumb on track */
        }
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #3B82F6; /* blue-500 */
            cursor: pointer;
        }

        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #1F2937; /* gray-800 */
        }
        ::-webkit-scrollbar-thumb {
            background: #4B5563; /* gray-600 */
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #6B7280; /* gray-500 */
        }

    </style>
</head>
<body class="bg-gray-900 text-gray-200 min-h-screen flex flex-col">

    <!-- Header -->
    <header class="bg-gray-800 shadow-lg rounded-b-lg sticky top-0 z-10">
        <div class="container mx-auto px-4 py-4 flex flex-wrap justify-between items-center gap-4">
            <h1 class="text-2xl md:text-3xl font-bold text-white">Algorithm Playground</h1>
            <!-- Tabs -->
            <div class="flex flex-wrap bg-gray-700 rounded-lg p-1">
                <button id="tab-sorting" class="tab-btn bg-blue-600 text-white px-3 py-2 rounded-md text-sm font-medium">Sorting</button>
                <button id="tab-searching" class="tab-btn text-gray-300 px-3 py-2 rounded-md text-sm font-medium">Searching</button>
                <button id="tab-pathfinding" class="tab-btn text-gray-300 px-3 py-2 rounded-md text-sm font-medium">Pathfinding</button>
                <button id="tab-dp" class="tab-btn text-gray-300 px-3 py-2 rounded-md text-sm font-medium">Dynamic Programming</button>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <main class="container mx-auto p-4 flex-grow flex flex-col lg:flex-row gap-4">

        <!-- Left Panel: Controls & Complexity -->
        <div class="w-full lg:w-1/3 xl:w-1/4 flex flex-col gap-4">
            
            <!-- Controls Panel -->
            <div class="bg-gray-800 p-4 rounded-lg shadow-xl">
                <h2 class="text-xl font-bold mb-4 border-b border-gray-700 pb-2">Controls</h2>
                
                <!-- Sorting Controls (Visible by default) -->
                <div id="controls-sorting">
                    <div class="mb-4">
                        <label for="algo-select-sorting" class="block text-sm font-medium text-gray-400 mb-1">Algorithm</label>
                        <select id="algo-select-sorting" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="bubbleSort">Bubble Sort</option>
                            <option value="mergeSort">Merge Sort</option>
                            <option value="quickSort">Quick Sort</option>
                            <option value="insertionSort">Insertion Sort</option>
                            <option value="selectionSort">Selection Sort</option>
                            <option value="heapSort">Heap Sort</option>
                        </select>
                    </div>
                    <div class="mb-4">
                        <label for="speed-slider-sorting" class="block text-sm font-medium text-gray-400 mb-1">Speed</label>
                        <input id="speed-slider-sorting" type="range" min="10" max="500" value="100" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                    </div>
                     <div class="mb-4">
                        <label for="size-slider-sorting" class="block text-sm font-medium text-gray-400 mb-1">Array Size (Random)</label>
                        <input id="size-slider-sorting" type="range" min="10" max="100" value="50" class="w-full h-2 rounded-lg appearance-none cursor-pointer">
                    </div>
                    <div class="mb-4">
                        <label for="custom-array-sorting" class="block text-sm font-medium text-gray-400 mb-1">Custom Array (e.g., 50,10,88)</label>
                        <textarea id="custom-array-sorting" rows="2" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Enter comma-separated numbers"></textarea>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-2 mb-2">
                        <button id="btn-generate-array" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Use Random Array</button>
                        <button id="btn-use-custom-array-sorting" class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Use Custom Array</button>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-2">
                        <button id="btn-start-sorting" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Start Sort</button>
                        <button id="btn-stop-sorting" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 opacity-50 cursor-not-allowed" disabled>Stop</button>
                    </div>
                </div>

                <!-- Searching Controls (Hidden by default) -->
                <div id="controls-searching" class="hidden">
                    <div class="mb-4">
                        <label for="algo-select-searching" class="block text-sm font-medium text-gray-400 mb-1">Algorithm</label>
                        <select id="algo-select-searching" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="linearSearch">Linear Search</option>
                            <option value="binarySearch">Binary Search</option>
                        </select>
                    </div>
                    <div class="mb-4">
                        <label for="target-input-searching" class="block text-sm font-medium text-gray-400 mb-1">Target Value</label>
                        <input id="target-input-searching" type="number" min="0" value="42" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-2">
                    </div>
                    <div class="mb-4">
                        <label for="custom-array-searching" class="block text-sm font-medium text-gray-400 mb-1">Custom Array (e.g., 50,10,88)</label>
                        <textarea id="custom-array-searching" rows="2" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500" placeholder="Enter comma-separated numbers"></textarea>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-2 mb-2">
                        <button id="btn-generate-array-searching" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Use Random Array</button>
                        <button id="btn-use-custom-array-searching" class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Use Custom Array</button>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-2">
                        <button id="btn-start-searching" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Start Search</button>
                        <button id="btn-stop-searching" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 opacity-50 cursor-not-allowed" disabled>Stop</button>
                    </div>
                    <p class="text-xs text-gray-500 mt-2">Note: Binary Search will automatically sort the array first.</p>
                </div>

                <!-- Pathfinding Controls (Hidden by default) -->
                <div id="controls-pathfinding" class="hidden">
                    <div class="mb-4">
                        <label for="algo-select-pathfinding" class="block text-sm font-medium text-gray-400 mb-1">Algorithm</label>
                        <select id="algo-select-pathfinding" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="dijkstra">Dijkstra's Algorithm</option>
                            <option value="aStar">A* Search</option>
                            <option value="bfs">Breadth-First Search (BFS)</option>
                            <option value="dfs">Depth-First Search (DFS)</option>
                        </select>
                    </div>
                    <p class="text-sm text-gray-400 mb-4">
                        Click/Drag to add walls. <br>
                        Drag Start (Green) & End (Red) nodes.
                    </p>
                    <div class="flex flex-col sm:flex-row gap-2 mb-2">
                        <button id="btn-reset-grid" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Reset Grid</button>
                        <button id="btn-clear-path" class="flex-1 bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Clear Path</button>
                    </div>
                    <div class="flex flex-col sm:flex-row gap-2">
                        <button id="btn-start-pathfinding" class="flex-1 bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Start Search</button>
                        <button id="btn-stop-pathfinding" class="flex-1 bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 opacity-50 cursor-not-allowed" disabled>Stop</button>
                    </div>
                </div>

                <!-- DP Controls (Hidden by default) -->
                <div id="controls-dp" class="hidden">
                    <div class="mb-4">
                        <label for="algo-select-dp" class="block text-sm font-medium text-gray-400 mb-1">Algorithm</label>
                        <select id="algo-select-dp" class="w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                            <option value="fibonacci">Fibonacci (Memoized)</option>
                            <option value="knapsack">0/1 Knapsack</option>
                            <option value="lcs">Longest Common Subsequence</option>
                        </select>
                    </div>
                    <!-- Dynamic controls for DP -->
                    <div id="dp-inputs-container">
                        <!-- JS will populate this -->
                    </div>
                    <div class="flex flex-col sm:flex-row gap-2 mt-4">
                        <button id="btn-start-dp" class="w-full bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200">Start</button>
                        <button id="btn-stop-dp" class="w-full bg-red-600 hover:bg-red-700 text-white font-bold py-2 px-4 rounded-lg transition duration-200 opacity-50 cursor-not-allowed" disabled>Stop</button>
                    </div>
                </div>
            </div>

            <!-- Complexity Panel -->
            <div class="bg-gray-800 p-4 rounded-lg shadow-xl flex-grow">
                <h2 class="text-xl font-bold mb-4 border-b border-gray-700 pb-2">Complexity Analysis</h2>
                <div id="complexity-info">
                    <!-- Content is dynamically inserted by JS -->
                </div>
            </div>
        </div>

        <!-- Right Panel: Visualizer -->
        <div class="w-full lg:w-2/3 xl:w-3/4 bg-gray-800 p-4 rounded-lg shadow-xl flex items-center justify-center min-h-[400px] lg:min-h-[60vh]">
            
            <!-- Sorting Visualizer (Visible by default) -->
            <div id="visualizer-sorting" class="w-full h-full flex items-end justify-center gap-[1px]">
                <!-- Bars are dynamically inserted by JS -->
            </div>

            <!-- Searching Visualizer (Hidden by default) -->
            <div id="visualizer-searching" class="hidden w-full h-full flex items-end justify-center gap-[1px]">
                <!-- Bars are dynamically inserted by JS -->
            </div>

            <!-- Pathfinding Visualizer (Hidden by default) -->
            <div id="visualizer-pathfinding" class="hidden w-full h-full aspect-square max-w-[80vh]">
                <div id="grid-container" class="grid w-full h-full">
                    <!-- Grid cells are dynamically inserted by JS -->
                </div>
            </div>

            <!-- DP Visualizer (Hidden by default) -->
            <div id="visualizer-dp" class="hidden w-full h-full flex-col items-center justify-center p-4">
                <p class="text-gray-400 text-lg">Dynamic Programming Visualizer</D>
                <p class="text-gray-500">Visualization for this algorithm is coming soon!</p>
                <!-- DP Table/Result will go here -->
                <div id="dp-output-container" class="w-full h-full mt-4 overflow-auto"></div>
            </div>
        </div>
    </main>
    
    <!-- JavaScript -->
    <script type="module">
        // --- STATE MANAGEMENT ---
        let currentView = 'sorting'; // 'sorting', 'searching', 'pathfinding', 'dp'
        let currentSortingAlgorithm = 'bubbleSort';
        let currentSearchingAlgorithm = 'linearSearch';
        let currentPathfindingAlgorithm = 'dijkstra';
        let currentDPAlgorithm = 'fibonacci';
        
        let sortSpeed = 100;
        let arraySize = 50;
        let sortingArray = [];
        let searchingArray = []; // For the searching tab
        
        // Global stop flag
        let forceStop = false;
        
        // State flags
        let isSorting = false;
        let isSearching = false;
        let isPathfinding = false;
        let isDPRunning = false;

        const GRID_ROWS = 25;
        const GRID_COLS = 25;
        let grid = [];
        let startNode = { row: 5, col: 5 };
        let endNode = { row: 19, col: 19 };
        let isDrawingWalls = false;
        let isMovingStart = false;
        let isMovingEnd = false;

        // --- COMPLEXITY DATA ---
        const complexityData = {
            bubbleSort: {
                title: 'Bubble Sort',
                time: {
                    best: 'O(n)',
                    average: 'O(n²)',
                    worst: 'O(n²)',
                },
                space: 'O(1)',
                explanation: `
                    <p class="mb-2"><strong class="text-gray-300">Time:</strong> It has an average and worst-case time of <code class="code">O(n²)</code> because it uses nested loops to compare and swap elements. For each of the 'n' elements, it may scan through 'n' other elements.</p>
                    <p class="mb-2"><strong class="text-gray-300">Best Case:</strong> The best case is <code class="code">O(n)</code>, which occurs if the array is already sorted and an optimized version is used that stops after an iteration with no swaps.</p>
                    <p><strong class="text-gray-300">Space:</strong> It's an in-place sorting algorithm, meaning it only requires a constant amount of extra memory (<code class="code">O(1)</code>) for temporary variables during swaps.</p>
                `
            },
            insertionSort: {
                title: 'Insertion Sort',
                time: {
                    best: 'O(n)',
                    average: 'O(n²)',
                    worst: 'O(n²)',
                },
                space: 'O(1)',
                explanation: `
                    <p class="mb-2"><strong class="text-gray-300">Time:</strong> The worst/average case is <code class="code">O(n²)</code>. It iterates through the array, and for each element, it shifts all larger elements to its right. This results in nested loop behavior.</p>
                    <p class="mb-2"><strong class="text-gray-300">Best Case:</strong> The best case is <code class="code">O(n)</code>, which occurs if the array is already sorted. The inner loop condition will never be met, so it just does a single pass.</p>
                    <p><strong class="text-gray-300">Space:</strong> It is an in-place, stable sorting algorithm with <code class="code">O(1)</code> space complexity.</p>
                `
            },
            selectionSort: {
                title: 'Selection Sort',
                time: {
                    best: 'O(n²)',
                    average: 'O(n²)',
                    worst: 'O(n²)',
                },
                space: 'O(1)',
                explanation: `
                    <p class="mb-2"><strong class="text-gray-300">Time:</strong> The time complexity is always <code class="code">O(n²)</code>, regardless of the initial order. It performs two nested loops: the outer loop selects an element, and the inner loop finds the minimum element in the remaining unsorted portion.</p>
                    <p><strong class="text-gray-300">Space:</strong> It is an in-place algorithm with <code class="code">O(1)</code> space complexity. It only needs one extra variable to store the index of the current minimum.</p>
                `
            },
            heapSort: {
                title: 'Heap Sort',
                time: {
                    best: 'O(n log n)',
                    average: 'O(n log n)',
                    worst: 'O(n log n)',
                },
                space: 'O(1)',
                explanation: `
                    <p class="mb-2"><strong class="text-gray-300">Time:</strong> It has a consistent <code class="code">O(n log n)</code> time complexity. Building the initial max-heap takes <code class="code">O(n)</code> time. Then, it repeatedly extracts the max element (root) and heapifies the rest, which takes <code class="code">O(log n)</code> time for each of the 'n' elements.</p>
                    <p><strong class="text-gray-300">Space:</strong> It is an in-place sort with <code class="code">O(1)</code> space. The heap is built within the array itself. (Note: if recursion is used for heapify, it may take O(log n) stack space).</p>
                `
            },
            mergeSort: {
                title: 'Merge Sort',
                time: {
                    best: 'O(n log n)',
                    average: 'O(n log n)',
                    worst: 'O(n log n)',
                },
                space: 'O(n)',
                explanation: `
                    <p class="mb-2"><strong class="text-gray-300">Time:</strong> As a divide-and-conquer algorithm, it consistently performs at <code class="code">O(n log n)</code>. The 'log n' comes from recursively splitting the array, and the 'n' comes from the work done at each level to merge the sub-arrays.</p>
                    <p><strong class="text-gray-300">Space:</strong> It requires <code class="code">O(n)</code> auxiliary space because it needs to create temporary arrays to merge the sorted halves. It is not an in-place sort.</p>
                `
            },
            quickSort: {
                title: 'Quick Sort',
                time: {
                    best: 'O(n log n)',
                    average: 'O(n log n)',
                    worst: 'O(n²)',
                },
                space: 'O(log n)',
                explanation: `
                    <p class="mb-2"><strong class="text-gray-300">Time (Average):</strong> Like Merge Sort, its average time is <code class="code">O(n log n)</code>. It works by partitioning the array and recursively sorting the partitions.</p>
                    <p class="mb-2"><strong class="text-gray-300">Worst Case:</strong> The worst case is <code class="code">O(n²)</code>. This happens when the chosen pivot is consistently the smallest or largest element, leading to unbalanced partitions (e.g., on an already-sorted array).</p>
                    <p><strong class="text-gray-300">Space:</strong> The space complexity is <code class="code">O(log n)</code> on average, which accounts for the space used by the recursion call stack. In the worst case, this can be <code class="code">O(n)</code>.</p>
                `
            },
            linearSearch: {
                title: 'Linear Search',
                time: {
                    best: 'O(1)',
                    average: 'O(n)',
                    worst: 'O(n)',
                },
                space: 'O(1)',
                explanation: `
                    <p class="mb-2"><strong class="text-gray-300">Time:</strong> It sequentially checks each element of the list until a match is found or the whole list has been searched. In the worst case (<code class="code">O(n)</code>), the element is at the end or not present. In the best case (<code class="code">O(1)</code>), it's the first element.</p>
                    <p><strong class="text-gray-300">Space:</strong> It requires no extra space, so it's <code class="code">O(1)</code>.</p>
                `
            },
            binarySearch: {
                title: 'Binary Search',
                time: {
                    best: 'O(1)',
                    average: 'O(log n)',
                    worst: 'O(log n)',
                },
                space: 'O(1)',
                explanation: `
                    <p class="mb-2"><strong class="text-gray-300">Time:</strong> This algorithm works on <strong class="text-gray-300">sorted arrays</strong>. It repeatedly divides the search interval in half. This "divide and conquer" approach leads to a logarithmic time complexity <code class="code">O(log n)</code>. The best case is <code class="code">O(1)</code> if the target is the middle element.</p>
                    <p><strong class="text-gray-300">Space:</strong> The iterative version has <code class="code">O(1)</code> space. A recursive version would require <code class="code">O(log n)</code> stack space.</p>
                `
            },
            dijkstra: {
                title: "Dijkstra's Algorithm",
                time: {
                    best: 'O(E + V log V)',
                    average: 'O(E + V log V)',
                    worst: 'O(E + V log V)',
                },
                space: 'O(V)',
                explanation: `
                    <p class="mb-2"><strong class="text-gray-300">Notation:</strong> 'V' is the number of vertices (nodes/cells) and 'E' is the number of edges (connections).</p>
                    <p class="mb-2"><strong class="text-gray-300">Time:</strong> When implemented with a min-priority queue (like a binary heap), the time complexity is <code class="code">O(E log V)</code> or <code class="code">O((V + E) log V)</code>. In our grid, E is at most 4V, so this simplifies to <code class="code">O(V log V)</code>. It explores nodes in order of increasing distance from the start.</p>
                    <p><strong class="text-gray-300">Space:</strong> The algorithm needs to store distances and 'previous node' references for all vertices, leading to a space complexity of <code class="code">O(V)</code>.</p>
                `
            },
            aStar: {
                title: "A* Search",
                time: {
                    best: 'O(V+E)',
                    average: 'O(V+E)',
                    worst: 'O(V²)',
                },
                space: 'O(V)',
                explanation: `
                    <p class="mb-2"><strong class="text-gray-300">Time:</strong> The time complexity heavily depends on the heuristic 'h'. In the best case, with a perfect heuristic, it runs as fast as <code class="code">O(V+E)</code>. In the worst case (e.g., on a grid), it can degrade to <code class="code">O(V²)</code>, similar to Dijkstra.</p>
                    <p class="mb-2"><strong class="text-gray-300">Logic:</strong> A* is an extension of Dijkstra. It optimizes the search by using a heuristic function <code class="code">f(n) = g(n) + h(n)</code>, where <code class="code">g(n)</code> is the cost from the start and <code class="code">h(n)</code> is the estimated cost to the end. It prioritizes nodes that seem closer to the goal.</p>
                    <p><strong class="text-gray-300">Space:</strong> It needs to store all nodes in the open list (priority queue), leading to <code class="code">O(V)</code> space complexity.</p>
                `
            },
            bfs: {
                title: "Breadth-First Search (BFS)",
                time: {
                    best: 'O(V + E)',
                    average: 'O(V + E)',
                    worst: 'O(V + E)',
                },
                space: 'O(V)',
                explanation: `
                    <p class="mb-2"><strong class="text-gray-300">Time:</strong> BFS explores the graph layer by layer. It must visit every vertex 'V' and check every edge 'E' in the worst case, so its time complexity is <code class="code">O(V + E)</code>. In our grid, this is <code class="code">O(V)</code>.</p>
                    <p class="mb-2"><strong class="text-gray-300">Logic:</strong> It uses a Queue (First-In, First-Out) to explore neighbors. This guarantees that it finds the shortest path in terms of the number of edges for an unweighted graph.</p>
                    <p><strong class="text-gray-300">Space:</strong> The queue can, in the worst case, hold all vertices at a given "layer". For a dense graph, this can be <code class="code">O(V)</code>.</p>
                `
            },
            dfs: {
                title: "Depth-First Search (DFS)",
                time: {
                    best: 'O(V + E)',
                    average: 'O(V + E)',
                    worst: 'O(V + E)',
                },
                space: 'O(V)',
                explanation: `
                    <p class="mb-2"><strong class="text-gray-300">Time:</strong> Like BFS, DFS must visit every vertex and edge in the worst case, leading to a <code class="code">O(V + E)</code> complexity.</p>
                    <p class="mb-2"><strong class="text-gray-300">Logic:</strong> It uses a Stack (Last-In, First-Out) to explore. It goes as deep as possible down one path before backtracking. It is good for finding *if* a path exists, but it is not guaranteed to find the shortest path.</p>
                    <p><strong class="text-gray-300">Space:</strong> The space complexity is determined by the size of the recursion stack (or explicit stack), which in the worst case can be <code class="code">O(V)</code> if the graph is a single long path.</p>
                `
            },
            fibonacci: {
                title: "Fibonacci (Memoized DP)",
                time: {
                    best: 'O(n)',
                    average: 'O(n)',
                    worst: 'O(n)',
                },
                space: 'O(n)',
                explanation: `
                    <p class="mb-2"><strong class="text-gray-300">Time:</strong> A naive recursive solution is <code class="code">O(2ⁿ)</code> due to repeated calculations. By using memoization (a form of DP), we store the result of each <code class="code">fib(k)</code>. Each value from 1 to 'n' is computed only once, leading to a <code class="code">O(n)</code> time complexity.</p>
                    <p><strong class="text-gray-300">Space:</strong> We need to store the computed values in an array or map up to 'n', so the space complexity is <code class="code">O(n)</code>.</p>
                `
            },
            knapsack: {
                title: "0/1 Knapsack (DP)",
                time: {
                    best: 'O(N * W)',
                    average: 'O(N * W)',
                    worst: 'O(N * W)',
                },
                space: 'O(N * W)',
                explanation: `
                    <p class="mb-2"><strong class="text-gray-300">Notation:</strong> 'N' is the number of items, 'W' is the capacity of the knapsack.</p>
                    <p class="mb-2"><strong class="text-gray-300">Time:</strong> The standard DP solution involves building a 2D table of size <code class="code">N x W</code>. Each cell <code class="code">dp[i][w]</code> is computed in constant time. Therefore, the total time is <code class="code">O(N * W)</code>.</p>
                    <p><strong class="text-gray-300">Space:</strong> Storing this 2D table requires <code class="code">O(N * W)</code> space. This can be optimized to <code class="code">O(W)</code> space by only storing the previous row.</p>
                `
            },
            lcs: {
                title: "Longest Common Subsequence (DP)",
                time: {
                    best: 'O(M * N)',
                    average: 'O(M * N)',
                    worst: 'O(M * N)',
                },
                space: 'O(M * N)',
                explanation: `
                    <p class="mb-2"><strong class="text-gray-300">Notation:</strong> 'M' and 'N' are the lengths of the two input strings.</p>
                    <p class="mb-2"><strong class="text-gray-300">Time:</strong> Similar to Knapsack, this algorithm builds a 2D table of size <code class="code">M x N</code>. Each cell <code class="code">dp[i][j]</code> (the LCS of string1[0..i] and string2[0..j]) is computed in constant time, leading to a <code class="code">O(M * N)</code> runtime.</p>
                    <p><strong class="text-gray-300">Space:</strong> The 2D table requires <code class="code">O(M * N)</code> space to store all subproblem solutions. This is needed to reconstruct the actual subsequence.</p>
                `
            }
        };

        // --- DOM ELEMENTS ---
        const tabSorting = document.getElementById('tab-sorting');
        const tabSearching = document.getElementById('tab-searching');
        const tabPathfinding = document.getElementById('tab-pathfinding');
        const tabDp = document.getElementById('tab-dp');
        
        const controlsSorting = document.getElementById('controls-sorting');
        const controlsSearching = document.getElementById('controls-searching');
        const controlsPathfinding = document.getElementById('controls-pathfinding');
        const controlsDp = document.getElementById('controls-dp');
        
        const visualizerSorting = document.getElementById('visualizer-sorting');
        const visualizerSearching = document.getElementById('visualizer-searching');
        const visualizerPathfinding = document.getElementById('visualizer-pathfinding');
        const visualizerDp = document.getElementById('visualizer-dp');
        const gridContainer = document.getElementById('grid-container');

        // Sorting controls
        const algoSelectSorting = document.getElementById('algo-select-sorting');
        const speedSliderSorting = document.getElementById('speed-slider-sorting');
        const sizeSliderSorting = document.getElementById('size-slider-sorting');
        const customArraySorting = document.getElementById('custom-array-sorting');
        const btnGenerateArray = document.getElementById('btn-generate-array');
        const btnUseCustomArraySorting = document.getElementById('btn-use-custom-array-sorting');
        const btnStartSorting = document.getElementById('btn-start-sorting');
        const btnStopSorting = document.getElementById('btn-stop-sorting');

        // Searching controls
        const algoSelectSearching = document.getElementById('algo-select-searching');
        const targetInputSearching = document.getElementById('target-input-searching');
        const customArraySearching = document.getElementById('custom-array-searching');
        const btnGenerateArraySearching = document.getElementById('btn-generate-array-searching');
        const btnUseCustomArraySearching = document.getElementById('btn-use-custom-array-searching');
        const btnStartSearching = document.getElementById('btn-start-searching');
        const btnStopSearching = document.getElementById('btn-stop-searching');

        // Pathfinding controls
        const algoSelectPathfinding = document.getElementById('algo-select-pathfinding');
        const btnResetGrid = document.getElementById('btn-reset-grid');
        const btnClearPath = document.getElementById('btn-clear-path');
        const btnStartPathfinding = document.getElementById('btn-start-pathfinding');
        const btnStopPathfinding = document.getElementById('btn-stop-pathfinding');

        // DP controls
        const algoSelectDp = document.getElementById('algo-select-dp');
        const dpInputsContainer = document.getElementById('dp-inputs-container');
        const dpOutputContainer = document.getElementById('dp-output-container');
        const btnStartDp = document.getElementById('btn-start-dp');
        const btnStopDp = document.getElementById('btn-stop-dp');

        const complexityInfo = document.getElementById('complexity-info');

        // --- UTILITY FUNCTIONS ---
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        
        const stopAlgorithm = () => {
            forceStop = true;
            // Re-enable controls immediately
            if (isSorting) enableControls('sorting');
            if (isSearching) enableControls('searching');
            if (isPathfinding) enableControls('pathfinding');
            if (isDPRunning) enableControls('dp');
        };

        const disableControls = (view) => {
            forceStop = false; // Reset stop flag on start
            
            if (view === 'sorting') {
                isSorting = true;
                btnStartSorting.disabled = true;
                btnGenerateArray.disabled = true;
                btnUseCustomArraySorting.disabled = true;
                algoSelectSorting.disabled = true;
                sizeSliderSorting.disabled = true;
                customArraySorting.disabled = true;
                btnStartSorting.classList.add('opacity-50', 'cursor-not-allowed');
                btnGenerateArray.classList.add('opacity-50', 'cursor-not-allowed');
                btnUseCustomArraySorting.classList.add('opacity-50', 'cursor-not-allowed');
                
                // Enable Stop button
                btnStopSorting.disabled = false;
                btnStopSorting.classList.remove('opacity-50', 'cursor-not-allowed');

            } else if (view === 'searching') {
                isSearching = true;
                btnStartSearching.disabled = true;
                btnGenerateArraySearching.disabled = true;
                btnUseCustomArraySearching.disabled = true;
                algoSelectSearching.disabled = true;
                targetInputSearching.disabled = true;
                customArraySearching.disabled = true;
                btnStartSearching.classList.add('opacity-50', 'cursor-not-allowed');
                btnGenerateArraySearching.classList.add('opacity-50', 'cursor-not-allowed');
                btnUseCustomArraySearching.classList.add('opacity-50', 'cursor-not-allowed');

                btnStopSearching.disabled = false;
                btnStopSearching.classList.remove('opacity-50', 'cursor-not-allowed');

            } else if (view === 'pathfinding') {
                isPathfinding = true;
                btnStartPathfinding.disabled = true;
                btnResetGrid.disabled = true;
                btnClearPath.disabled = true;
                algoSelectPathfinding.disabled = true;
                btnStartPathfinding.classList.add('opacity-50', 'cursor-not-allowed');
                btnResetGrid.classList.add('opacity-50', 'cursor-not-allowed');
                btnClearPath.classList.add('opacity-50', 'cursor-not-allowed');

                btnStopPathfinding.disabled = false;
                btnStopPathfinding.classList.remove('opacity-50', 'cursor-not-allowed');
                
            } else if (view === 'dp') {
                isDPRunning = true;
                btnStartDp.disabled = true;
                algoSelectDp.disabled = true;
                btnStartDp.classList.add('opacity-50', 'cursor-not-allowed');
                // Disable all inputs
                dpInputsContainer.querySelectorAll('input, textarea').forEach(el => el.disabled = true);
                
                btnStopDp.disabled = false;
                btnStopDp.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        };

        const enableControls = (view) => {
             if (view === 'sorting') {
                isSorting = false;
                btnStartSorting.disabled = false;
                btnGenerateArray.disabled = false;
                btnUseCustomArraySorting.disabled = false;
                algoSelectSorting.disabled = false;
                sizeSliderSorting.disabled = false;
                customArraySorting.disabled = false;
                btnStartSorting.classList.remove('opacity-50', 'cursor-not-allowed');
                btnGenerateArray.classList.remove('opacity-50', 'cursor-not-allowed');
                btnUseCustomArraySorting.classList.remove('opacity-50', 'cursor-not-allowed');

                btnStopSorting.disabled = true;
                btnStopSorting.classList.add('opacity-50', 'cursor-not-allowed');

            } else if (view === 'searching') {
                isSearching = false;
                btnStartSearching.disabled = false;
                btnGenerateArraySearching.disabled = false;
                btnUseCustomArraySearching.disabled = false;
                algoSelectSearching.disabled = false;
                targetInputSearching.disabled = false;
                customArraySearching.disabled = false;
                btnStartSearching.classList.remove('opacity-50', 'cursor-not-allowed');
                btnGenerateArraySearching.classList.remove('opacity-50', 'cursor-not-allowed');
                btnUseCustomArraySearching.classList.remove('opacity-50', 'cursor-not-allowed');

                btnStopSearching.disabled = true;
                btnStopSearching.classList.add('opacity-50', 'cursor-not-allowed');
                
            } else if (view === 'pathfinding') {
                isPathfinding = false;
                btnStartPathfinding.disabled = false;
                btnResetGrid.disabled = false;
                btnClearPath.disabled = false;
                algoSelectPathfinding.disabled = false;
                btnStartPathfinding.classList.remove('opacity-50', 'cursor-not-allowed');
                btnResetGrid.classList.remove('opacity-50', 'cursor-not-allowed');
                btnClearPath.classList.remove('opacity-50', 'cursor-not-allowed');
                
                btnStopPathfinding.disabled = true;
                btnStopPathfinding.classList.add('opacity-50', 'cursor-not-allowed');
                
            } else if (view === 'dp') {
                isDPRunning = false;
                btnStartDp.disabled = false;
                algoSelectDp.disabled = false;
                btnStartDp.classList.remove('opacity-50', 'cursor-not-allowed');
                dpInputsContainer.querySelectorAll('input, textarea').forEach(el => el.disabled = false);

                btnStopDp.disabled = true;
                btnStopDp.classList.add('opacity-50', 'cursor-not-allowed');
            }
        };

        // --- VIEW SWITCHING ---
        const switchView = (view) => {
            if (isSorting || isSearching || isPathfinding || isDPRunning) {
                stopAlgorithm();
            }
            
            currentView = view;
            
            // Reset all tabs
            [tabSorting, tabSearching, tabPathfinding, tabDp].forEach(tab => {
                tab.classList.remove('bg-blue-600', 'text-white');
                tab.classList.add('text-gray-300');
            });
            // Hide all controls
            [controlsSorting, controlsSearching, controlsPathfinding, controlsDp].forEach(c => c.classList.add('hidden'));
            // Hide all visualizers
            [visualizerSorting, visualizerSearching, visualizerPathfinding, visualizerDp].forEach(v => v.classList.add('hidden'));
            visualizerSorting.classList.remove('flex'); // Special case for flex
            visualizerSearching.classList.remove('flex'); // Special case for flex
            visualizerDp.classList.remove('flex'); // Special case for flex

            if (view === 'sorting') {
                tabSorting.classList.add('bg-blue-600', 'text-white');
                controlsSorting.classList.remove('hidden');
                visualizerSorting.classList.remove('hidden');
                visualizerSorting.classList.add('flex');
                if (sortingArray.length === 0) generateArray(false); // Generate random array
                else drawArray(sortingArray, visualizerSorting); // Redraw existing

            } else if (view === 'searching') {
                tabSearching.classList.add('bg-blue-600', 'text-white');
                controlsSearching.classList.remove('hidden');
                visualizerSearching.classList.remove('hidden');
                visualizerSearching.classList.add('flex');
                if (searchingArray.length === 0) generateArray(true); // Generate random array for searching
                else drawArray(searchingArray, visualizerSearching, true); // Redraw existing

            } else if (view === 'pathfinding') {
                tabPathfinding.classList.add('bg-blue-600', 'text-white');
                controlsPathfinding.classList.remove('hidden');
                visualizerPathfinding.classList.remove('hidden');
                if (grid.length === 0) createGrid();

            } else if (view === 'dp') {
                tabDp.classList.add('bg-blue-600', 'text-white');
                controlsDp.classList.remove('hidden');
                visualizerDp.classList.remove('hidden');
                visualizerDp.classList.add('flex'); // Use flex for column layout
                updateDPInputs();
            }
            
            updateComplexityInfo();
        };

        // --- DP INPUTS LOGIC ---
        const updateDPInputs = () => {
            currentDPAlgorithm = algoSelectDp.value;
            dpInputsContainer.innerHTML = ''; // Clear old inputs
            dpOutputContainer.innerHTML = ''; // Clear old output
            
            const baseInputClass = "w-full bg-gray-700 border border-gray-600 text-white rounded-lg px-3 py-2 mt-1";
            const baseLabelClass = "block text-sm font-medium text-gray-400";

            if (currentDPAlgorithm === 'fibonacci') {
                dpInputsContainer.innerHTML = `
                    <div class="mb-4">
                        <label for="dp-fib-n" class="${baseLabelClass}">Fibonacci (n):</label>
                        <input id="dp-fib-n" type="number" min="0" max="50" value="10" class="${baseInputClass}">
                    </div>
                `;
            } else if (currentDPAlgorithm === 'knapsack') {
                dpInputsContainer.innerHTML = `
                    <div class="mb-4">
                        <label for="dp-knapsack-weights" class="${baseLabelClass}">Weights (comma-sep):</label>
                        <input id="dp-knapsack-weights" type="text" value="1,2,4,5" class="${baseInputClass}">
                    </div>
                    <div class="mb-4">
                        <label for="dp-knapsack-values" class="${baseLabelClass}">Values (comma-sep):</label>
                        <input id="dp-knapsack-values" type="text" value="5,4,8,6" class="${baseInputClass}">
                    </div>
                    <div class="mb-4">
                        <label for="dp-knapsack-capacity" class="${baseLabelClass}">Capacity:</label>
                        <input id="dp-knapsack-capacity" type="number" min="1" value="5" class="${baseInputClass}">
                    </div>
                `;
            } else if (currentDPAlgorithm === 'lcs') {
                dpInputsContainer.innerHTML = `
                    <div class="mb-4">
                        <label for="dp-lcs-s1" class="${baseLabelClass}">String 1:</label>
                        <input id="dp-lcs-s1" type="text" value="AGGTAB" class="${baseInputClass}">
                    </div>
                    <div class="mb-4">
                        <label for="dp-lcs-s2" class="${baseLabelClass}">String 2:</label>
                        <input id="dp-lcs-s2" type="text" value="GXTXAYB" class="${baseInputClass}">
                    </div>
                `;
            }
            updateComplexityInfo();
        };

        // --- COMPLEXITY PANEL LOGIC ---
        const updateComplexityInfo = () => {
            let algoKey;
            switch (currentView) {
                case 'sorting': algoKey = currentSortingAlgorithm; break;
                case 'searching': algoKey = currentSearchingAlgorithm; break;
                case 'pathfinding': algoKey = currentPathfindingAlgorithm; break;
                case 'dp': algoKey = currentDPAlgorithm; break;
                default: algoKey = 'bubbleSort';
            }
            
            const data = complexityData[algoKey];

            if (!data) {
                complexityInfo.innerHTML = '<p>Select an algorithm to see its analysis.</p>';
                return;
            }
            
            // Shared style for code blocks
            const codeStyle = "font-mono bg-gray-700 px-2 py-1 rounded-md text-sm text-blue-300";

            complexityInfo.innerHTML = `
                <h3 class="text-2xl font-bold text-white mb-3">${data.title}</h3>
                <div class="space-y-3 text-gray-400 text-sm">
                    <div>
                        <h4 class="font-semibold text-gray-300 mb-1">Time Complexity</h4>
                        <ul class="list-disc list-inside pl-2 space-y-1">
                            <li>Best: <code class="${codeStyle}">${data.time.best}</code></li>
                            <li>Average: <code class="${codeStyle}">${data.time.average}</code></li>
                            <li>Worst: <code class="${codeStyle}">${data.time.worst}</code></li>
                        </ul>
                    </div>
                    <div>
                        <h4 class="font-semibold text-gray-300 mb-1">Space Complexity</h4>
                        <p class="pl-2">Total: <code class="${codeStyle}">${data.space}</code></p>
                    </div>
                    <div>
                        <h4 class="font-semibold text-gray-300 mb-1">Explanation</h4>
                        <div class="pl-2 space-y-2 text-gray-400">${data.explanation.replace(/<code class="code">/g, `<code class="${codeStyle}">`)}</div>
                    </div>
                </div>
            `;
        };

        // --- SORTING/SEARCHING ARRAY LOGIC ---
        
        // 1. Draw Array
        const drawArray = (array, visualizer, showLabels = false) => {
            visualizer.innerHTML = '';
            const maxVal = Math.max(...array);
            const showText = (array.length <= 50) || showLabels; // Always show for searching, or if not crowded

            for (let i = 0; i < array.length; i++) {
                const value = array[i];
                const percentHeight = (value / maxVal) * 90 + 10; // Height from 10% to 100%
                const bar = document.createElement('div');
                bar.style.height = `${percentHeight}%`;
                bar.classList.add('sort-bar', 'bg-blue-500');
                bar.style.width = `${100 / array.length}%`;
                
                if (showText) {
                    const label = document.createElement('span');
                    label.innerText = value;
                    label.classList.add('sort-bar-label');
                    if (array.length > 30) label.style.fontSize = '8px'; // Smaller text if still crowded
                    bar.appendChild(label);
                }
                
                visualizer.appendChild(bar);
            }
        };

        // 2. Generate Random Array
        const generateArray = (isSearchTab) => {
            if (isSorting || isSearching) return;
            
            const size = isSearchTab ? 30 : arraySize; // Use fixed size for searching for clarity
            let newArray = [];
            for (let i = 0; i < size; i++) {
                const value = Math.floor(Math.random() * 90) + 10;
                newArray.push(value);
            }
            
            if (isSearchTab) {
                if (currentSearchingAlgorithm === 'binarySearch') {
                    newArray.sort((a,b) => a-b);
                }
                searchingArray = [...newArray];
                drawArray(searchingArray, visualizerSearching, true);
            } else {
                sortingArray = [...newArray];
                drawArray(sortingArray, visualizerSorting);
            }
        };

        // 3. Parse Custom Array
        const parseCustomArray = (input) => {
            return input
                .split(',')
                .map(item => parseInt(item.trim(), 10))
                .filter(num => !isNaN(num) && num > 0);
        };
        
        // 4. Use Custom Array
        const useCustomArray = (isSearchTab) => {
            if (isSorting || isSearching) return;
            
            const input = isSearchTab ? customArraySearching.value : customArraySorting.value;
            let newArray = parseCustomArray(input);
            
            if (newArray.length === 0) {
                // simple feedback, no alert()
                console.error("Invalid custom array. Please enter comma-separated positive numbers.");
                if (isSearchTab) customArraySearching.value = "ERROR: Invalid Input";
                else customArraySorting.value = "ERROR: Invalid Input";
                return;
            }
            
            if (newArray.length > 100) {
                newArray = newArray.slice(0, 100); // Cap size
            }
            
            if (isSearchTab) {
                if (currentSearchingAlgorithm === 'binarySearch') {
                    newArray.sort((a,b) => a-b);
                }
                searchingArray = [...newArray];
                drawArray(searchingArray, visualizerSearching, true);
            } else {
                sortingArray = [...newArray];
                drawArray(sortingArray, visualizerSorting, true); // Show labels for custom sort
            }
        };

        // 5. Start Sorting
        const startSorting = async () => {
            if (sortingArray.length === 0) generateArray(false);
            
            disableControls('sorting');
            const bars = visualizerSorting.getElementsByClassName('sort-bar');

            switch (currentSortingAlgorithm) {
                case 'bubbleSort':
                    await bubbleSort(bars);
                    break;
                case 'insertionSort':
                    await insertionSort(bars);
                    break;
                case 'selectionSort':
                    await selectionSort(bars);
                    break;
                case 'heapSort':
                    await heapSort(bars);
                    break;
                case 'mergeSort':
                    await mergeSort(bars, 0, sortingArray.length - 1);
                    break;
                case 'quickSort':
                    await quickSort(bars, 0, sortingArray.length - 1);
                    break;
            }
            
            if (forceStop) {
                // If stopped, just re-enable controls
                enableControls('sorting');
                return;
            }
            
            // Finish animation
            for (let i = 0; i < bars.length; i++) {
                if (forceStop) break;
                bars[i].classList.remove('bg-blue-500', 'bg-red-500', 'bg-yellow-500', 'bg-purple-500');
                bars[i].classList.add('bg-green-500');
                await sleep(5);
            }

            enableControls('sorting');
        };

        // 6. Sorting Algorithms (with forceStop checks)
        const bubbleSort = async (bars) => {
            for (let i = 0; i < sortingArray.length - 1; i++) {
                for (let j = 0; j < sortingArray.length - i - 1; j++) {
                    if (forceStop) return;
                    
                    bars[j].classList.add('bg-red-500');
                    bars[j+1].classList.add('bg-red-500');
                    await sleep(sortSpeed);
                    if (forceStop) return;

                    if (sortingArray[j] > sortingArray[j+1]) {
                        [sortingArray[j], sortingArray[j+1]] = [sortingArray[j+1], sortingArray[j]];
                        drawArray(sortingArray, visualizerSorting, true); // Redraw to update labels
                        // Re-add highlights after redraw
                        bars[j].classList.add('bg-red-500'); 
                        bars[j+1].classList.add('bg-red-500');
                        await sleep(sortSpeed);
                        if (forceStop) return;
                    }
                    
                    bars[j].classList.remove('bg-red-500');
                    bars[j+1].classList.remove('bg-red-500');
                }
                if (forceStop) return;
                bars[sortingArray.length - 1 - i].classList.add('bg-green-500');
            }
            if (!forceStop) bars[0].classList.add('bg-green-500');
        };

        const insertionSort = async (bars) => {
            for (let i = 1; i < sortingArray.length; i++) {
                if (forceStop) return;
                let key = sortingArray[i];
                let j = i - 1;
                
                bars[i].classList.add('bg-red-500'); // Current element to insert
                await sleep(sortSpeed);
                if (forceStop) return;

                while (j >= 0 && sortingArray[j] > key) {
                    if (forceStop) return;
                    bars[j].classList.add('bg-yellow-500'); // Element being shifted
                    sortingArray[j + 1] = sortingArray[j];
                    j = j - 1;
                    
                    drawArray(sortingArray, visualizerSorting, true);
                    // Re-add highlights
                    bars[i].classList.add('bg-red-500');
                    for (let k = j + 2; k <= i; k++) bars[k].classList.add('bg-yellow-500');

                    await sleep(sortSpeed);
                    if (forceStop) return;
                }
                sortingArray[j + 1] = key;
                
                drawArray(sortingArray, visualizerSorting, true);
                if (forceStop) return;

                await sleep(sortSpeed);
            }
        };

        const selectionSort = async (bars) => {
            for (let i = 0; i < sortingArray.length - 1; i++) {
                if (forceStop) return;
                let minIdx = i;
                bars[i].classList.add('bg-red-500'); // Current position to fill

                for (let j = i + 1; j < sortingArray.length; j++) {
                    if (forceStop) return;
                    bars[j].classList.add('bg-yellow-500'); // Current element being checked
                    await sleep(sortSpeed);
                    if (forceStop) return;

                    if (sortingArray[j] < sortingArray[minIdx]) {
                        if (minIdx !== i) bars[minIdx].classList.remove('bg-purple-500'); // Remove old min highlight
                        minIdx = j;
                        bars[minIdx].classList.add('bg-purple-500'); // New min highlight
                    }
                    bars[j].classList.remove('bg-yellow-500');
                }
                
                if (forceStop) return;

                // Swap
                [sortingArray[i], sortingArray[minIdx]] = [sortingArray[minIdx], sortingArray[i]];
                drawArray(sortingArray, visualizerSorting, true);

                if(bars[minIdx]) bars[minIdx].classList.remove('bg-purple-500');
                if(bars[i]) bars[i].classList.remove('bg-red-500');
                if(bars[i]) bars[i].classList.add('bg-green-500'); // Mark as sorted
                await sleep(sortSpeed);
            }
            if (!forceStop && bars[sortingArray.length - 1]) {
                bars[sortingArray.length - 1].classList.add('bg-green-500');
            }
        };

        const heapSort = async (bars) => {
            let n = sortingArray.length;
            if (forceStop) return;

            // Build max heap
            for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
                if (forceStop) return;
                await heapify(bars, n, i);
            }

            // One by one extract an element from heap
            for (let i = n - 1; i > 0; i--) {
                if (forceStop) return;
                bars[0].classList.add('bg-red-500');
                bars[i].classList.add('bg-red-500');
                await sleep(sortSpeed);
                if (forceStop) return;

                [sortingArray[0], sortingArray[i]] = [sortingArray[i], sortingArray[0]];
                drawArray(sortingArray, visualizerSorting, true);
                
                bars[i].classList.add('bg-green-500'); // Mark as sorted

                // call max heapify on the reduced heap
                await heapify(bars, i, 0);
            }
            if (!forceStop && bars[0]) bars[0].classList.add('bg-green-500');
        };

        const heapify = async (bars, n, i) => {
            if (forceStop) return;
            let largest = i; // Initialize largest as root
            let left = 2 * i + 1;
            let right = 2 * i + 2;

            if(bars[i]) bars[i].classList.add('bg-red-500'); // Root of subtree
            if (left < n && bars[left]) bars[left].classList.add('bg-yellow-500');
            if (right < n && bars[right]) bars[right].classList.add('bg-yellow-500');
            await sleep(sortSpeed);
            if (forceStop) return;

            if (left < n && sortingArray[left] > sortingArray[largest]) {
                largest = left;
            }
            if (right < n && sortingArray[right] > sortingArray[largest]) {
                largest = right;
            }

            if (largest !== i) {
                [sortingArray[i], sortingArray[largest]] = [sortingArray[largest], sortingArray[i]];
                
                drawArray(sortingArray, visualizerSorting, true);
                
                await sleep(sortSpeed);
                if (forceStop) return;

                // Recursively heapify the affected sub-tree
                await heapify(bars, n, largest);
            } else {
                 if(bars[i]) bars[i].classList.remove('bg-red-500');
                 if (left < n && bars[left]) bars[left].classList.remove('bg-yellow-500');
                 if (right < n && bars[right]) bars[right].classList.remove('bg-yellow-500');
            }
        };

        const mergeSort = async (bars, left, right) => {
            if (forceStop || left >= right) return;
            
            const mid = Math.floor((left + right) / 2);
            
            await mergeSort(bars, left, mid);
            if (forceStop) return;
            await mergeSort(bars, mid + 1, right);
            if (forceStop) return;
            await merge(bars, left, mid, right);
        };
        
        const merge = async (bars, left, mid, right) => {
            if (forceStop) return;
            let leftArr = sortingArray.slice(left, mid + 1);
            let rightArr = sortingArray.slice(mid + 1, right + 1);
            
            let i = 0, j = 0, k = left;
            
            while (i < leftArr.length && j < rightArr.length) {
                if (forceStop) return;
                if(bars[left + i]) bars[left + i].classList.add('bg-red-500');
                if(bars[mid + 1 + j]) bars[mid + 1 + j].classList.add('bg-red-500');
                await sleep(sortSpeed);
                if (forceStop) return;
                
                if (leftArr[i] <= rightArr[j]) {
                    sortingArray[k] = leftArr[i];
                    i++;
                } else {
                    sortingArray[k] = rightArr[j];
                    j++;
                }
                
                drawArray(sortingArray, visualizerSorting, true);
                for(let barIdx = left; barIdx <= right; barIdx++) {
                     if(bars[barIdx]) bars[barIdx].classList.add('bg-yellow-500');
                }
                
                await sleep(sortSpeed);
                if (forceStop) return;
                k++;
            }
            
            while (i < leftArr.length) {
                if (forceStop) return;
                sortingArray[k] = leftArr[i];
                drawArray(sortingArray, visualizerSorting, true);
                for(let barIdx = left; barIdx <= right; barIdx++) {
                     if(bars[barIdx]) bars[barIdx].classList.add('bg-yellow-500');
                }
                await sleep(sortSpeed);
                i++;
                k++;
            }
            
            while (j < rightArr.length) {
                if (forceStop) return;
                sortingArray[k] = rightArr[j];
                drawArray(sortingArray, visualizerSorting, true);
                for(let barIdx = left; barIdx <= right; barIdx++) {
                     if(bars[barIdx]) bars[barIdx].classList.add('bg-yellow-500');
                }
                await sleep(sortSpeed);
                j++;
                k++;
            }
            
            if (forceStop) return;
            // Mark as sorted in this range
            for (let barIdx = left; barIdx <= right; barIdx++) {
                if(bars[barIdx]) {
                    bars[barIdx].classList.remove('bg-yellow-500');
                    if (right - left === sortingArray.length - 1) { // Only if it's the final merge
                        bars[barIdx].classList.add('bg-green-500');
                    }
                }
            }
        };

        const quickSort = async (bars, low, high) => {
            if (forceStop || low < 0 || high < 0 || low >= high) {
                if(low >= 0 && low < bars.length) bars[low]?.classList.add('bg-green-500');
                if(high >= 0 && high < bars.length) bars[high]?.classList.add('bg-green-500');
                return;
            }
            
            let pi = await partition(bars, low, high);
            if (forceStop) return;

            // Mark pivot as sorted
            if (pi >= 0 && pi < bars.length) bars[pi].classList.add('bg-green-500');

            await Promise.all([
                quickSort(bars, low, pi - 1),
                quickSort(bars, pi + 1, high)
            ]);
        };
        
        const partition = async (bars, low, high) => {
            if (forceStop) return low; // return a valid index
            
            let pivot = sortingArray[high];
            let i = low - 1;
            
            if(bars[high]) bars[high].classList.add('bg-yellow-500'); // Pivot color
            
            for (let j = low; j < high; j++) {
                if (forceStop) return i;
                if(bars[j]) bars[j].classList.add('bg-red-500'); // Current element
                await sleep(sortSpeed);
                if (forceStop) return i;
                
                if (sortingArray[j] < pivot) {
                    i++;
                    if(bars[i]) bars[i].classList.add('bg-purple-500');
                    if(bars[j]) bars[j].classList.add('bg-purple-500');
                    await sleep(sortSpeed);
                    if (forceStop) return i;

                    [sortingArray[i], sortingArray[j]] = [sortingArray[j], sortingArray[i]];
                    drawArray(sortingArray, visualizerSorting, true);
                    
                    // Re-apply colors
                    if(bars[high]) bars[high].classList.add('bg-yellow-500');
                    for (let k = low; k < high; k++) {
                        if (k === j) if(bars[k]) bars[k].classList.add('bg-red-500');
                        if (k === i) if(bars[k]) bars[k].classList.add('bg-purple-500');
                    }
                    
                    if(bars[i]) bars[i].classList.remove('bg-purple-500');
                    if(bars[j]) bars[j].classList.remove('bg-purple-500');
                }
                if(bars[j]) bars[j].classList.remove('bg-red-500');
            }
            
            if (forceStop) return i;
            
            // Swap pivot into place
            [sortingArray[i + 1], sortingArray[high]] = [sortingArray[high], sortingArray[i + 1]];
            drawArray(sortingArray, visualizerSorting, true);
            
            await sleep(sortSpeed);
            if(bars[high]) bars[high].classList.remove('bg-yellow-500');
            
            return i + 1;
        };


        // --- SEARCHING ALGORITHM LOGIC ---

        const startSearching = async () => {
            const target = parseInt(targetInputSearching.value, 10);
            if (isNaN(target)) {
                console.error("Please enter a valid number as target.");
                targetInputSearching.value = "ERROR: Invalid Target";
                return;
            }
            
            if (searchingArray.length === 0) {
                 useCustomArray(true);
                 if (searchingArray.length === 0) generateArray(true);
            }
            
            disableControls('searching');
            const bars = visualizerSearching.getElementsByClassName('sort-bar');
            let found = false;

            if (currentSearchingAlgorithm === 'linearSearch') {
                if (currentView === 'searching') {
                    // Ensure it's unsorted if it was just sorted
                    const isSorted = searchingArray.every((v, i, a) => !i || a[i-1] <= v);
                    if (isSorted) {
                        searchingArray.sort(() => Math.random() - 0.5); // Shuffle
                        drawArray(searchingArray, visualizerSearching, true);
                        await sleep(100);
                    }
                }
                found = await linearSearch(bars, target);
            } else if (currentSearchingAlgorithm === 'binarySearch') {
                // Ensure it's sorted
                const isSorted = searchingArray.every((v, i, a) => !i || a[i-1] <= v);
                if (!isSorted) {
                    searchingArray.sort((a,b) => a-b);
                    drawArray(searchingArray, visualizerSearching, true);
                    await sleep(100);
                }
                found = await binarySearch(bars, target);
            }
            
            if (forceStop) {
                enableControls('searching');
                return;
            }
            
            console.log("Found:", found);
            enableControls('searching');
        };

        const linearSearch = async (bars, target) => {
            for (let i = 0; i < bars.length; i++) {
                if (forceStop) return false;
                bars[i].classList.add('bg-red-500'); // Highlight current
                await sleep(sortSpeed);
                if (forceStop) return false;

                if (searchingArray[i] === target) {
                    bars[i].classList.remove('bg-red-500');
                    bars[i].classList.add('bg-green-500');
                    return true;
                }
                bars[i].classList.remove('bg-red-500');
                bars[i].classList.add('bg-gray-600'); // Mark as checked
            }
            return false;
        };

        const binarySearch = async (bars, target) => {
            let low = 0;
            let high = searchingArray.length - 1;

            while (low <= high) {
                if (forceStop) return false;
                let mid = Math.floor((low + high) / 2);
                
                // Highlight range
                for(let i=low; i<=high; i++) {
                    if(bars[i]) bars[i].classList.add('bg-yellow-500');
                }
                if(bars[mid]) bars[mid].classList.remove('bg-yellow-500');
                if(bars[mid]) bars[mid].classList.add('bg-red-500'); // Highlight mid
                await sleep(sortSpeed * 2);
                if (forceStop) return false;

                if (searchingArray[mid] === target) {
                    if(bars[mid]) bars[mid].classList.remove('bg-red-500');
                    if(bars[mid]) bars[mid].classList.add('bg-green-500');
                    for(let i=low; i<=high; i++) {
                        if(bars[i]) bars[i].classList.remove('bg-yellow-500');
                    }
                    return true;
                }
                
                if (searchingArray[mid] < target) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
                
                // Clear highlights
                for(let i=0; i<bars.length; i++) {
                    if(bars[i]) {
                        bars[i].classList.remove('bg-yellow-500', 'bg-red-500');
                        if (i < low || i > high) bars[i].classList.add('bg-gray-600'); // Discarded
                    }
                }
            }
            return false;
        };


        // --- PATHFINDING ALGORITHM LOGIC ---
        
        // 1. Node class
        class Node {
            constructor(row, col) {
                this.row = row;
                this.col = col;
                this.isStart = row === startNode.row && col === startNode.col;
                this.isEnd = row === endNode.row && col === endNode.col;
                this.isWall = false;
                this.isVisited = false;
                this.distance = Infinity; // g(n) for A*
                this.f = Infinity; // f(n) for A*
                this.h = Infinity; // h(n) for A*
                this.previousNode = null;
                this.domElement = document.createElement('div');
                this.domElement.classList.add('grid-cell');
                this.domElement.dataset.row = row;
                this.domElement.dataset.col = col;
                if (this.isStart) this.domElement.classList.add('start');
                if (this.isEnd) this.domElement.classList.add('end');
                
                // Add event listeners
                this.domElement.addEventListener('mousedown', () => handleMouseDown(row, col));
                this.domElement.addEventListener('mouseenter', () => handleMouseEnter(row, col));
                this.domElement.addEventListener('mouseup', () => handleMouseUp());
                this.domElement.addEventListener('touchstart', (e) => { e.preventDefault(); handleMouseDown(row, col); });
                this.domElement.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    const touch = e.touches[0];
                    const element = document.elementFromPoint(touch.clientX, touch.clientY);
                    if(element && element.classList.contains('grid-cell')) {
                        handleMouseEnter(element.dataset.row, element.dataset.col);
                    }
                });
                this.domElement.addEventListener('touchend', (e) => { e.preventDefault(); handleMouseUp(); });
            }
        }
        
        // 2. Create Grid
        const createGrid = () => {
            if (isPathfinding) return;
            grid = [];
            gridContainer.innerHTML = '';
            gridContainer.style.gridTemplateColumns = `repeat(${GRID_COLS}, 1fr)`;
            
            for (let r = 0; r < GRID_ROWS; r++) {
                const row = [];
                for (let c = 0; c < GRID_COLS; c++) {
                    const node = new Node(r, c);
                    row.push(node);
                    gridContainer.appendChild(node.domElement);
                }
                grid.push(row);
            }
        };
        
        // 3. Reset Grid
        const resetGrid = () => {
            if (isPathfinding) stopAlgorithm();
            for(let r=0; r < GRID_ROWS; r++) {
                for (let c=0; c < GRID_COLS; c++) {
                    const node = grid[r][c];
                    node.isWall = false;
                    node.isVisited = false;
                    node.distance = Infinity;
                    node.f = Infinity;
                    node.h = Infinity;
                    node.previousNode = null;
                    node.domElement.classList.remove('wall', 'visited', 'path');
                    if (r === startNode.row && c === startNode.col) {
                         node.isStart = true;
                         node.domElement.classList.add('start');
                    } else {
                        node.isStart = false;
                        node.domElement.classList.remove('start');
                    }
                    
                    if (r === endNode.row && c === endNode.col) {
                        node.isEnd = true;
                        node.domElement.classList.add('end');
                    } else {
                        node.isEnd = false;
                        node.domElement.classList.remove('end');
                    }
                }
            }
        };
        
        // 4. Clear Path
        const clearSearch = () => {
             if (isPathfinding) stopAlgorithm();
             for(let r=0; r < GRID_ROWS; r++) {
                for (let c=0; c < GRID_COLS; c++) {
                    const node = grid[r][c];
                    node.isVisited = false;
                    node.distance = Infinity;
                    node.f = Infinity;
                    node.h = Infinity;
                    node.previousNode = null;
                    if (!node.isStart && !node.isEnd && !node.isWall) {
                         node.domElement.classList.remove('visited', 'path');
                    }
                }
            }
        }

        // 5. Mouse Handlers for Walls
        const handleMouseDown = (row, col) => {
            if (isPathfinding) return;
            const node = grid[row][col];
            if (node.isStart) {
                isMovingStart = true;
            } else if (node.isEnd) {
                isMovingEnd = true;
            } else {
                isDrawingWalls = true;
                node.isWall = !node.isWall;
                node.domElement.classList.toggle('wall', node.isWall);
            }
        };
        
        const handleMouseEnter = (row, col) => {
            if (isPathfinding) return;
            // Ensure row/col are valid numbers
            row = parseInt(row, 10);
            col = parseInt(col, 10);
            if (isNaN(row) || isNaN(col)) return;

            const node = grid[row][col];
            if (isDrawingWalls) {
                if (!node.isStart && !node.isEnd) {
                    node.isWall = true;
                    node.domElement.classList.add('wall');
                }
            } else if (isMovingStart) {
                if (!node.isWall && !node.isEnd) {
                    grid[startNode.row][startNode.col].isStart = false;
                    grid[startNode.row][startNode.col].domElement.classList.remove('start');
                    startNode = { row, col };
                    node.isStart = true;
                    node.domElement.classList.add('start');
                }
            } else if (isMovingEnd) {
                 if (!node.isWall && !node.isStart) {
                    grid[endNode.row][endNode.col].isEnd = false;
                    grid[endNode.row][endNode.col].domElement.classList.remove('end');
                    endNode = { row, col };
                    node.isEnd = true;
                    node.domElement.classList.add('end');
                }
            }
        };
        
        const handleMouseUp = () => {
            isDrawingWalls = false;
            isMovingStart = false;
            isMovingEnd = false;
        };
        
        // 6. Start Pathfinding
        const startPathfinding = async () => {
            disableControls('pathfinding');
            clearSearch(); // Clear previous path/visited nodes
            
            const start = grid[startNode.row][startNode.col];
            const end = grid[endNode.row][endNode.col];
            
            let found = false;
            switch (currentPathfindingAlgorithm) {
                case 'dijkstra':
                    found = await dijkstra(start, end);
                    break;
                case 'aStar':
                    found = await aStar(start, end);
                    break;
                case 'bfs':
                    found = await bfs(start, end);
                    break;
                case 'dfs':
                    found = await dfs(start, end);
                    break;
            }
            
            if (forceStop) {
                enableControls('pathfinding');
                return;
            }

            if (found) {
                await animateShortestPath(end);
            } else {
                console.log("No path found");
                // You could add a modal/toast here to inform the user
            }
            
            enableControls('pathfinding');
        };
        
        // 7. Pathfinding Algorithms (with forceStop)
        const dijkstra = async (start, end) => {
            const unvisitedNodes = getAllNodes();
            start.distance = 0;
            
            while(!!unvisitedNodes.length) {
                if (forceStop) return false;
                sortNodesByDistance(unvisitedNodes);
                const closestNode = unvisitedNodes.shift();
                
                if (closestNode.isWall) continue;
                
                if (closestNode.distance === Infinity) return false; // Trapped
                
                closestNode.isVisited = true;
                if (!closestNode.isStart && !closestNode.isEnd) {
                    closestNode.domElement.classList.add('visited');
                }
                
                await sleep(10); // Speed of visualization
                
                if (closestNode === end) return true; // Found
                
                updateUnvisitedNeighbors(closestNode);
            }
            return false;
        };

        const aStar = async (start, end) => {
            const openSet = [start];
            start.distance = 0; // g(n)
            start.h = heuristic(start, end);
            start.f = start.h; // f(n) = g(n) + h(n)

            while (!!openSet.length) {
                if (forceStop) return false;
                
                openSet.sort((a, b) => a.f - b.f);
                const currentNode = openSet.shift();

                if (currentNode.isWall) continue;
                if (currentNode.isVisited) continue; // Already processed
                
                currentNode.isVisited = true;
                if (!currentNode.isStart && !currentNode.isEnd) {
                    currentNode.domElement.classList.add('visited');
                }
                
                await sleep(10);

                if (currentNode === end) return true; // Found

                const neighbors = getNeighbors(currentNode, true); // Get all neighbors
                for (const neighbor of neighbors) {
                    if (neighbor.isWall || neighbor.isVisited) continue;

                    const tentativeGScore = currentNode.distance + 1; // All weights are 1
                    
                    if (tentativeGScore < neighbor.distance) {
                        neighbor.previousNode = currentNode;
                        neighbor.distance = tentativeGScore;
                        neighbor.h = heuristic(neighbor, end);
                        neighbor.f = neighbor.distance + neighbor.h;
                        
                        if (!openSet.some(node => node.row === neighbor.row && node.col === neighbor.col)) {
                            openSet.push(neighbor);
                        }
                    }
                }
            }
            return false; // Not found
        };

        const heuristic = (nodeA, nodeB) => {
            // Manhattan distance
            const dRow = Math.abs(nodeA.row - nodeB.row);
            const dCol = Math.abs(nodeA.col - nodeB.col);
            return dRow + dCol;
        };
        
        const bfs = async (start, end) => {
            const queue = [start];
            start.isVisited = true;
            
            while (!!queue.length) {
                if (forceStop) return false;
                const currentNode = queue.shift();
                
                if (currentNode.isWall) continue;
                
                if (!currentNode.isStart && !currentNode.isEnd) {
                    currentNode.domElement.classList.add('visited');
                }
                await sleep(10);
                
                if (currentNode === end) return true; // Found
                
                const neighbors = getNeighbors(currentNode, false); // Get unvisited neighbors
                for (const neighbor of neighbors) {
                    if (!neighbor.isVisited && !neighbor.isWall) {
                        neighbor.isVisited = true;
                        neighbor.previousNode = currentNode;
                        queue.push(neighbor);
                    }
                }
            }
            return false; // Not found
        };

        const dfs = async (start, end) => {
            const stack = [start];
            
            while (!!stack.length) {
                if (forceStop) return false;
                const currentNode = stack.pop();
                
                if (currentNode.isWall || currentNode.isVisited) continue;
                
                currentNode.isVisited = true;
                if (!currentNode.isStart && !currentNode.isEnd) {
                    currentNode.domElement.classList.add('visited');
                }
                await sleep(10);

                if (currentNode === end) return true; // Found
                
                const neighbors = getNeighbors(currentNode, false); // Get unvisited neighbors
                for (const neighbor of neighbors) {
                    if (!neighbor.isVisited && !neighbor.isWall) {
                        neighbor.previousNode = currentNode;
                        stack.push(neighbor);
                    }
                }
            }
            return false; // Not found
        };
        
        // 8. Pathfinding Helper Functions
        const sortNodesByDistance = (nodes) => {
            nodes.sort((a, b) => a.distance - b.distance);
        };
        
        const getAllNodes = () => {
            const nodes = [];
            for (const row of grid) {
                for (const node of row) {
                    nodes.push(node);
                }
            }
            return nodes;
        };
        
        const updateUnvisitedNeighbors = (node) => {
            const neighbors = getNeighbors(node, false); // Get unvisited neighbors
            for (const neighbor of neighbors) {
                if (!neighbor.isWall) {
                    neighbor.distance = node.distance + 1;
                    neighbor.previousNode = node;
                }
            }
        };
        
        const getNeighbors = (node, includeVisited = false) => {
            const neighbors = [];
            const { row, col } = node;
            if (row > 0) neighbors.push(grid[row - 1][col]);
            if (row < GRID_ROWS - 1) neighbors.push(grid[row + 1][col]);
            if (col > 0) neighbors.push(grid[row][col - 1]);
            if (col < GRID_COLS - 1) neighbors.push(grid[row][col + 1]);
            
            if (includeVisited) {
                return neighbors;
            }
            return neighbors.filter(n => !n.isVisited);
        };
        
        const animateShortestPath = async (endNode) => {
            let currentNode = endNode;
            const path = [];
            while(currentNode !== null) {
                path.push(currentNode);
                currentNode = currentNode.previousNode;
            }
            path.reverse();
            
            for (const node of path) {
                if (forceStop) return;
                if (!node.isStart && !node.isEnd) {
                    node.domElement.classList.add('path');
                    await sleep(25);
                }
            }
        };


        // --- DYNAMIC PROGRAMMING LOGIC ---
        
        const startDP = async () => {
            disableControls('dp');
            dpOutputContainer.innerHTML = '<p class="text-yellow-400">Working...</p>';

            switch(currentDPAlgorithm) {
                case 'fibonacci':
                    await visualizeFibonacci();
                    break;
                case 'knapsack':
                    await visualizeKnapsack();
                    break;
                case 'lcs':
                    await visualizeLCS();
                    break;
            }

            if (forceStop) {
                dpOutputContainer.innerHTML += '<p class="text-red-500 font-bold">STOPPED BY USER</p>';
            }
            enableControls('dp');
        };
        
        const visualizeFibonacci = async () => {
            const n = parseInt(document.getElementById('dp-fib-n').value, 10);
            if (isNaN(n) || n < 0) {
                dpOutputContainer.innerHTML = '<p class="text-red-500">Invalid input for n.</p>';
                return;
            }
            
            let memo = new Array(n + 1).fill(null);
            dpOutputContainer.innerHTML = `<h3 class="text-lg font-bold mb-2">Memoization Table (n=${n})</h3>`;
            const table = document.createElement('div');
            table.classList.add('flex', 'flex-wrap', 'gap-2');
            dpOutputContainer.appendChild(table);

            const fib = async (num) => {
                if (forceStop) return -1; // Error code for stop
                if (num <= 1) return num;
                
                let cell = table.querySelector(`[data-index='${num}']`);
                if (!cell) {
                    cell = document.createElement('div');
                    cell.dataset.index = num;
                    cell.classList.add('p-2', 'bg-gray-700', 'rounded-lg', 'font-mono', 'text-sm');
                    cell.innerHTML = `fib(${num}) = ?`;
                    table.appendChild(cell);
                    await sleep(200);
                    if (forceStop) return -1;
                }

                if (memo[num] !== null) {
                     cell.classList.add('bg-yellow-500');
                     await sleep(200);
                     if (forceStop) return -1;
                     cell.classList.remove('bg-yellow-500');
                    return memo[num];
                }
                
                cell.classList.add('bg-blue-500'); // Mark as computing
                await sleep(200);
                if (forceStop) return -1;


                let res1 = await fib(num - 1);
                if (forceStop) return -1;
                let res2 = await fib(num - 2);
                if (forceStop) return -1;
                
                let res = res1 + res2;
                memo[num] = res;
                
                cell.innerHTML = `fib(${num}) = ${res}`;
                cell.classList.remove('bg-blue-500');
                cell.classList.add('bg-green-600', 'text-white');
                await sleep(200);
                return res;
            };

            const result = await fib(n);
            if (!forceStop) {
                dpOutputContainer.innerHTML += `<h3 class="text-xl font-bold mt-4">Result: fib(${n}) = ${result}</h3>`;
            }
        };
        
        const visualizeKnapsack = async () => {
            // Placeholder - This visualization is complex
            dpOutputContainer.innerHTML = `
                <p class="text-gray-400">Knapsack visualization is complex and coming soon!</p>
                <p class="text-gray-500 text-sm">This would involve dynamically creating and filling a 2D grid (N x W) to show how the <code class="font-mono bg-gray-700 px-1 rounded">dp[i][w]</code> values are computed step-by-step.</p>
            `;
            console.log("Knapsack logic to be implemented");
            for (let i=0; i<5; i++) {
                if (forceStop) return;
                await sleep(100); // Simulate work
            }
        };
        
        const visualizeLCS = async () => {
            // Placeholder - This visualization is complex
            dpOutputContainer.innerHTML = `
                <p class="text-gray-400">LCS visualization is complex and coming soon!</p>
                <p class="text-gray-500 text-sm">This would involve creating a 2D grid (M x N) for the two strings and animating the cell-by-cell comparison to fill the <code class="font-mono bg-gray-700 px-1 rounded">dp[i][j]</code> table.</p>
            `;
            console.log("LCS logic to be implemented");
            for (let i=0; i<5; i++) {
                if (forceStop) return;
                await sleep(100); // Simulate work
            }
        };


        // --- EVENT LISTENERS ---
        window.addEventListener('DOMContentLoaded', () => {
            // Tabs
            tabSorting.addEventListener('click', () => switchView('sorting'));
            tabSearching.addEventListener('click', () => switchView('searching'));
            tabPathfinding.addEventListener('click', () => switchView('pathfinding'));
            tabDp.addEventListener('click', () => switchView('dp'));
            
            // Sorting Controls
            algoSelectSorting.addEventListener('change', (e) => {
                currentSortingAlgorithm = e.target.value;
                updateComplexityInfo();
            });
            speedSliderSorting.addEventListener('input', (e) => {
                sortSpeed = 510 - e.target.value;
            });
             sizeSliderSorting.addEventListener('input', (e) => {
                arraySize = e.target.value;
                generateArray(false); // Generate new random array on size change
            });
            btnGenerateArray.addEventListener('click', () => generateArray(false));
            btnUseCustomArraySorting.addEventListener('click', () => useCustomArray(false));
            btnStartSorting.addEventListener('click', startSorting);
            btnStopSorting.addEventListener('click', stopAlgorithm);

            // Searching Controls
            algoSelectSearching.addEventListener('change', (e) => {
                currentSearchingAlgorithm = e.target.value;
                // Regenerate array for the new mode (sorted/unsorted)
                const input = customArraySearching.value;
                let newArray = parseCustomArray(input);
                if (newArray.length > 0) {
                    useCustomArray(true);
                } else {
                    generateArray(true);
                }
                updateComplexityInfo();
            });
            btnGenerateArraySearching.addEventListener('click', () => generateArray(true));
            btnUseCustomArraySearching.addEventListener('click', () => useCustomArray(true));
            btnStartSearching.addEventListener('click', startSearching);
            btnStopSearching.addEventListener('click', stopAlgorithm);
            
            // Pathfinding Controls
            algoSelectPathfinding.addEventListener('change', (e) => {
                currentPathfindingAlgorithm = e.target.value;
                updateComplexityInfo();
            });
            btnResetGrid.addEventListener('click', resetGrid);
            btnClearPath.addEventListener('click', clearSearch);
            btnStartPathfinding.addEventListener('click', startPathfinding);
            btnStopPathfinding.addEventListener('click', stopAlgorithm);

            // DP Controls
            algoSelectDp.addEventListener('change', updateDPInputs);
            btnStartDp.addEventListener('click', startDP);
            btnStopDp.addEventListener('click', stopAlgorithm);
            
            // Global mouse up for pathfinding
            document.body.addEventListener('mouseup', handleMouseUp);
            document.body.addEventListener('touchend', handleMouseUp);
            
            // Initial setup
            switchView('sorting'); // Start on sorting view
        });

    </script>
</body>
</html>

